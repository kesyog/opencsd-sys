/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2Y: u32 = 0;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 41;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const OCSD_TRC_IDX_STR: &[u8; 2] = b"u\0";
pub const OCSD_DFRMTR_HAS_FSYNCS: u32 = 1;
pub const OCSD_DFRMTR_HAS_HSYNCS: u32 = 2;
pub const OCSD_DFRMTR_FRAME_MEM_ALIGN: u32 = 4;
pub const OCSD_DFRMTR_PACKED_RAW_OUT: u32 = 8;
pub const OCSD_DFRMTR_UNPACKED_RAW_OUT: u32 = 16;
pub const OCSD_DFRMTR_RESET_ON_4X_FSYNC: u32 = 32;
pub const OCSD_DFRMTR_VALID_MASK: u32 = 63;
pub const OCSD_DFRMTR_FRAME_SIZE: u32 = 16;
pub const OCSD_CMPNAME_PREFIX_SOURCE_READER: &[u8; 5] = b"SRDR\0";
pub const OCSD_CMPNAME_PREFIX_FRAMEDEFORMATTER: &[u8; 5] = b"DFMT\0";
pub const OCSD_CMPNAME_PREFIX_PKTPROC: &[u8; 5] = b"PKTP\0";
pub const OCSD_CMPNAME_PREFIX_PKTDEC: &[u8; 5] = b"PDEC\0";
pub const OCSD_MAX_VA_BITSIZE: u32 = 64;
pub const OCSD_VA_MASK: i32 = -1;
pub const OCSD_OPFLG_PKTPROC_NOFWD_BAD_PKTS: u32 = 16;
pub const OCSD_OPFLG_PKTPROC_NOMON_BAD_PKTS: u32 = 32;
pub const OCSD_OPFLG_PKTPROC_ERR_BAD_PKTS: u32 = 64;
pub const OCSD_OPFLG_PKTPROC_UNSYNC_ON_BAD_PKTS: u32 = 128;
pub const OCSD_OPFLG_PKTPROC_COMMON: u32 = 240;
pub const OCSD_OPFLG_COMP_MODE_MASK: u32 = 4294901760;
pub const OCSD_OPFLG_PKTDEC_ERROR_BAD_PKTS: u32 = 256;
pub const OCSD_OPFLG_PKTDEC_HALT_BAD_PKTS: u32 = 512;
pub const OCSD_OPFLG_N_UNCOND_DIR_BR_CHK: u32 = 1024;
pub const OCSD_OPFLG_STRICT_N_UNCOND_BR_CHK: u32 = 2048;
pub const OCSD_OPFLG_CHK_RANGE_CONTINUE: u32 = 4096;
pub const OCSD_OPFLG_PKTDEC_COMMON: u32 = 7936;
pub const OCSD_CREATE_FLG_PACKET_PROC: u32 = 1;
pub const OCSD_CREATE_FLG_FULL_DECODER: u32 = 2;
pub const OCSD_CREATE_FLG_INST_ID: u32 = 4;
pub const OCSD_BUILTIN_DCD_STM: &[u8; 4] = b"STM\0";
pub const OCSD_BUILTIN_DCD_ETMV3: &[u8; 6] = b"ETMV3\0";
pub const OCSD_BUILTIN_DCD_ETMV4I: &[u8; 7] = b"ETMV4I\0";
pub const OCSD_BUILTIN_DCD_ETMV4D: &[u8; 7] = b"ETMV4D\0";
pub const OCSD_BUILTIN_DCD_PTM: &[u8; 4] = b"PTM\0";
pub const OCSD_BUILTIN_DCD_ETE: &[u8; 4] = b"ETE\0";
pub const SWT_ID_VALID_MASK: u32 = 8388608;
pub const OCSD_STATS_REVISION: u32 = 1;
pub const OCSD_VER_MAJOR: u32 = 1;
pub const OCSD_VER_MINOR: u32 = 5;
pub const OCSD_VER_PATCH: u32 = 6;
pub const OCSD_VER_NUM: u32 = 66822;
pub const OCSD_VER_STRING: &[u8; 6] = b"1.5.6\0";
pub const OCSD_LIB_NAME: &[u8; 16] = b"OpenCSD Library\0";
pub const OCSD_LIB_SHORT_NAME: &[u8; 5] = b"OCSD\0";
pub const DATA_ADDR_EXPECTED_FLAG: u32 = 32;
pub const ETE_ARCH_VERSION: u32 = 5;
pub const ETE_OPFLG_PKTDEC_SRCADDR_N_ATOMS: u32 = 65536;
pub const ETM4_OPFLG_PKTDEC_AA64_OPCODE_CHK: u32 = 131072;
pub const ETE_ETM4_OPFLG_MASK: u32 = 196608;
pub const C_API_MSGLOGOUT_FLG_NONE: u32 = 0;
pub const C_API_MSGLOGOUT_FLG_FILE: u32 = 1;
pub const C_API_MSGLOGOUT_FLG_STDERR: u32 = 2;
pub const C_API_MSGLOGOUT_FLG_STDOUT: u32 = 4;
pub const C_API_MSGLOGOUT_MASK: u32 = 7;
pub const OCSD_CUST_DCD_PKT_CB_USE_MON: u32 = 1;
pub const OCSD_CUST_DCD_PKT_CB_USE_SINK: u32 = 2;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type ocsd_trc_index_t = u32;
#[doc = "< 0 No Error."]
pub const _ocsd_err_t_OCSD_OK: _ocsd_err_t = 0;
#[doc = "< 1 General systemic failure."]
pub const _ocsd_err_t_OCSD_ERR_FAIL: _ocsd_err_t = 1;
#[doc = "< 2 Internal memory allocation error."]
pub const _ocsd_err_t_OCSD_ERR_MEM: _ocsd_err_t = 2;
#[doc = "< 3 Component not initialised or initialisation failure."]
pub const _ocsd_err_t_OCSD_ERR_NOT_INIT: _ocsd_err_t = 3;
#[doc = "< 4 Invalid CoreSight Trace Source ID."]
pub const _ocsd_err_t_OCSD_ERR_INVALID_ID: _ocsd_err_t = 4;
#[doc = "< 5 Invalid handle passed to component."]
pub const _ocsd_err_t_OCSD_ERR_BAD_HANDLE: _ocsd_err_t = 5;
#[doc = "< 6 Invalid value parameter passed to component."]
pub const _ocsd_err_t_OCSD_ERR_INVALID_PARAM_VAL: _ocsd_err_t = 6;
#[doc = "< 7 Type mismatch on abstract interface"]
pub const _ocsd_err_t_OCSD_ERR_INVALID_PARAM_TYPE: _ocsd_err_t = 7;
#[doc = "< 8 File access error"]
pub const _ocsd_err_t_OCSD_ERR_FILE_ERROR: _ocsd_err_t = 8;
#[doc = "< 9 Trace protocol unsupported"]
pub const _ocsd_err_t_OCSD_ERR_NO_PROTOCOL: _ocsd_err_t = 9;
#[doc = "< 10 Cannot attach - attach device limit reached."]
pub const _ocsd_err_t_OCSD_ERR_ATTACH_TOO_MANY: _ocsd_err_t = 10;
#[doc = "< 11 Cannot attach - invalid parameter."]
pub const _ocsd_err_t_OCSD_ERR_ATTACH_INVALID_PARAM: _ocsd_err_t = 11;
#[doc = "< 12 Cannot detach - component not found."]
pub const _ocsd_err_t_OCSD_ERR_ATTACH_COMP_NOT_FOUND: _ocsd_err_t = 12;
#[doc = "< 13 source reader - file not found."]
pub const _ocsd_err_t_OCSD_ERR_RDR_FILE_NOT_FOUND: _ocsd_err_t = 13;
#[doc = "< 14 source reader - invalid initialisation parameter."]
pub const _ocsd_err_t_OCSD_ERR_RDR_INVALID_INIT: _ocsd_err_t = 14;
#[doc = "< 15 source reader - not trace decoder set."]
pub const _ocsd_err_t_OCSD_ERR_RDR_NO_DECODER: _ocsd_err_t = 15;
#[doc = "< 16 A decoder in the data path has returned a fatal error."]
pub const _ocsd_err_t_OCSD_ERR_DATA_DECODE_FATAL: _ocsd_err_t = 16;
#[doc = "< 17 Trace input to deformatter none-continuous"]
pub const _ocsd_err_t_OCSD_ERR_DFMTR_NOTCONTTRACE: _ocsd_err_t = 17;
#[doc = "< 18 Bad frame or half frame sync in trace deformatter"]
pub const _ocsd_err_t_OCSD_ERR_DFMTR_BAD_FHSYNC: _ocsd_err_t = 18;
#[doc = "< 19 Bad packet sequence"]
pub const _ocsd_err_t_OCSD_ERR_BAD_PACKET_SEQ: _ocsd_err_t = 19;
#[doc = "< 20 Invalid packet header"]
pub const _ocsd_err_t_OCSD_ERR_INVALID_PCKT_HDR: _ocsd_err_t = 20;
#[doc = "< 21 Interpreter failed - cannot recover - bad data or sequence"]
pub const _ocsd_err_t_OCSD_ERR_PKT_INTERP_FAIL: _ocsd_err_t = 21;
#[doc = "< 22 ISA not supported in decoder."]
pub const _ocsd_err_t_OCSD_ERR_UNSUPPORTED_ISA: _ocsd_err_t = 22;
#[doc = "< 23 Programmed trace configuration not supported by decoder."]
pub const _ocsd_err_t_OCSD_ERR_HW_CFG_UNSUPP: _ocsd_err_t = 23;
#[doc = "< 24 Packet not supported in decoder"]
pub const _ocsd_err_t_OCSD_ERR_UNSUPP_DECODE_PKT: _ocsd_err_t = 24;
#[doc = "< 25 reserved or unknown packet in decoder."]
pub const _ocsd_err_t_OCSD_ERR_BAD_DECODE_PKT: _ocsd_err_t = 25;
#[doc = "< 26 overrun in commit packet stack - tried to commit more than available"]
pub const _ocsd_err_t_OCSD_ERR_COMMIT_PKT_OVERRUN: _ocsd_err_t = 26;
#[doc = "< 27 unable to access required memory address"]
pub const _ocsd_err_t_OCSD_ERR_MEM_NACC: _ocsd_err_t = 27;
#[doc = "< 28 internal return stack overflow checks failed - popped more than we pushed."]
pub const _ocsd_err_t_OCSD_ERR_RET_STACK_OVERFLOW: _ocsd_err_t = 28;
#[doc = "< 29 No formatter in use - operation not valid."]
pub const _ocsd_err_t_OCSD_ERR_DCDT_NO_FORMATTER: _ocsd_err_t = 29;
#[doc = "< 30 Attempted to set an overlapping range in memory access map"]
pub const _ocsd_err_t_OCSD_ERR_MEM_ACC_OVERLAP: _ocsd_err_t = 30;
#[doc = "< 31 Memory access file could not be opened"]
pub const _ocsd_err_t_OCSD_ERR_MEM_ACC_FILE_NOT_FOUND: _ocsd_err_t = 31;
#[doc = "< 32 Attempt to re-use the same memory access file for a different address range"]
pub const _ocsd_err_t_OCSD_ERR_MEM_ACC_FILE_DIFF_RANGE: _ocsd_err_t = 32;
#[doc = "< 33 Address range in accessor set to invalid values"]
pub const _ocsd_err_t_OCSD_ERR_MEM_ACC_RANGE_INVALID: _ocsd_err_t = 33;
#[doc = "< 34 Memory accessor returned a bad read length value (larger than requested"]
pub const _ocsd_err_t_OCSD_ERR_MEM_ACC_BAD_LEN: _ocsd_err_t = 34;
#[doc = "< 35 test snapshot file parse error"]
pub const _ocsd_err_t_OCSD_ERR_TEST_SNAPSHOT_PARSE: _ocsd_err_t = 35;
#[doc = "< 36 test snapshot file parse information"]
pub const _ocsd_err_t_OCSD_ERR_TEST_SNAPSHOT_PARSE_INFO: _ocsd_err_t = 36;
#[doc = "< 37 test snapshot reader error"]
pub const _ocsd_err_t_OCSD_ERR_TEST_SNAPSHOT_READ: _ocsd_err_t = 37;
#[doc = "< 38 test snapshot to decode tree conversion error"]
pub const _ocsd_err_t_OCSD_ERR_TEST_SS_TO_DECODER: _ocsd_err_t = 38;
#[doc = "< 39 attempted to register a decoder with the same name as another one"]
pub const _ocsd_err_t_OCSD_ERR_DCDREG_NAME_REPEAT: _ocsd_err_t = 39;
#[doc = "< 40 attempted to find a decoder with a name that is not known in the library"]
pub const _ocsd_err_t_OCSD_ERR_DCDREG_NAME_UNKNOWN: _ocsd_err_t = 40;
#[doc = "< 41 attempted to find a decoder with a type that is not known in the library"]
pub const _ocsd_err_t_OCSD_ERR_DCDREG_TYPE_UNKNOWN: _ocsd_err_t = 41;
#[doc = "< 42 attempted to register too many custom decoders"]
pub const _ocsd_err_t_OCSD_ERR_DCDREG_TOOMANY: _ocsd_err_t = 42;
#[doc = "< 43 Attempt to connect or use and interface not supported by this decoder."]
pub const _ocsd_err_t_OCSD_ERR_DCD_INTERFACE_UNUSED: _ocsd_err_t = 43;
#[doc = "< 44 Opcode found while decoding program memory is illegal"]
pub const _ocsd_err_t_OCSD_ERR_INVALID_OPCODE: _ocsd_err_t = 44;
#[doc = "< 45 An optional limit on consecutive instructions in range during decode has been exceeded."]
pub const _ocsd_err_t_OCSD_ERR_I_RANGE_LIMIT_OVERRUN: _ocsd_err_t = 45;
#[doc = "< 46 Inconsistencies detected between trace and decode image (e.g. not taken unconditional instructions)"]
pub const _ocsd_err_t_OCSD_ERR_BAD_DECODE_IMAGE: _ocsd_err_t = 46;
pub const _ocsd_err_t_OCSD_ERR_LAST: _ocsd_err_t = 47;
#[doc = " Library Error return type"]
pub type _ocsd_err_t = ::std::os::raw::c_uint;
#[doc = " Library Error return type"]
pub use self::_ocsd_err_t as ocsd_err_t;
pub type ocsd_hndl_rdr_t = ::std::os::raw::c_uint;
pub type ocsd_hndl_err_log_t = ::std::os::raw::c_uint;
#[doc = "< No error logging."]
pub const _ocsd_err_severity_t_OCSD_ERR_SEV_NONE: _ocsd_err_severity_t = 0;
#[doc = "< Most severe error - perhaps fatal."]
pub const _ocsd_err_severity_t_OCSD_ERR_SEV_ERROR: _ocsd_err_severity_t = 1;
#[doc = "< Warning level. Inconsistent or incorrect data seen but can carry on decode processing"]
pub const _ocsd_err_severity_t_OCSD_ERR_SEV_WARN: _ocsd_err_severity_t = 2;
#[doc = "< Information only message. Use for debugging code or suspect input data."]
pub const _ocsd_err_severity_t_OCSD_ERR_SEV_INFO: _ocsd_err_severity_t = 3;
#[doc = "  Error Severity Type\n\n   Used to indicate the severity of an error, and also as the\n   error log verbosity level in the error logger.\n\n   The logger will ignore errors with a severity value higher than the\n   current verbosity level.\n\n   The value OCSD_ERR_SEV_NONE can only be used as a verbosity level to switch off logging,\n   not as a severity value on an error. The other values can be used as both error severity and\n   logger verbosity values."]
pub type _ocsd_err_severity_t = ::std::os::raw::c_uint;
#[doc = "  Error Severity Type\n\n   Used to indicate the severity of an error, and also as the\n   error log verbosity level in the error logger.\n\n   The logger will ignore errors with a severity value higher than the\n   current verbosity level.\n\n   The value OCSD_ERR_SEV_NONE can only be used as a verbosity level to switch off logging,\n   not as a severity value on an error. The other values can be used as both error severity and\n   logger verbosity values."]
pub use self::_ocsd_err_severity_t as ocsd_err_severity_t;
#[doc = "< Standard index + data packet"]
pub const _ocsd_datapath_op_t_OCSD_OP_DATA: _ocsd_datapath_op_t = 0;
#[doc = "< End of available trace data. No data packet."]
pub const _ocsd_datapath_op_t_OCSD_OP_EOT: _ocsd_datapath_op_t = 1;
#[doc = "< Flush existing data where possible, retain decode state. No data packet."]
pub const _ocsd_datapath_op_t_OCSD_OP_FLUSH: _ocsd_datapath_op_t = 2;
#[doc = "< Reset decode state - drop any existing partial data. No data packet."]
pub const _ocsd_datapath_op_t_OCSD_OP_RESET: _ocsd_datapath_op_t = 3;
#[doc = " Trace Datapath operations."]
pub type _ocsd_datapath_op_t = ::std::os::raw::c_uint;
#[doc = " Trace Datapath operations."]
pub use self::_ocsd_datapath_op_t as ocsd_datapath_op_t;
#[doc = "< Continue processing"]
pub const _ocsd_datapath_resp_t_OCSD_RESP_CONT: _ocsd_datapath_resp_t = 0;
#[doc = "< Continue processing  : a component logged a warning."]
pub const _ocsd_datapath_resp_t_OCSD_RESP_WARN_CONT: _ocsd_datapath_resp_t = 1;
#[doc = "< Continue processing  : a component logged an error."]
pub const _ocsd_datapath_resp_t_OCSD_RESP_ERR_CONT: _ocsd_datapath_resp_t = 2;
#[doc = "< Pause processing"]
pub const _ocsd_datapath_resp_t_OCSD_RESP_WAIT: _ocsd_datapath_resp_t = 3;
#[doc = "< Pause processing : a component logged a warning."]
pub const _ocsd_datapath_resp_t_OCSD_RESP_WARN_WAIT: _ocsd_datapath_resp_t = 4;
#[doc = "< Pause processing : a component logged an error."]
pub const _ocsd_datapath_resp_t_OCSD_RESP_ERR_WAIT: _ocsd_datapath_resp_t = 5;
#[doc = "< Processing Fatal Error :  component unintialised."]
pub const _ocsd_datapath_resp_t_OCSD_RESP_FATAL_NOT_INIT: _ocsd_datapath_resp_t = 6;
#[doc = "< Processing Fatal Error :  invalid data path operation."]
pub const _ocsd_datapath_resp_t_OCSD_RESP_FATAL_INVALID_OP: _ocsd_datapath_resp_t = 7;
#[doc = "< Processing Fatal Error :  invalid parameter in datapath call."]
pub const _ocsd_datapath_resp_t_OCSD_RESP_FATAL_INVALID_PARAM: _ocsd_datapath_resp_t = 8;
#[doc = "< Processing Fatal Error :  invalid trace data"]
pub const _ocsd_datapath_resp_t_OCSD_RESP_FATAL_INVALID_DATA: _ocsd_datapath_resp_t = 9;
#[doc = "< Processing Fatal Error :  internal system error."]
pub const _ocsd_datapath_resp_t_OCSD_RESP_FATAL_SYS_ERR: _ocsd_datapath_resp_t = 10;
#[doc = " Trace Datapath responses"]
pub type _ocsd_datapath_resp_t = ::std::os::raw::c_uint;
#[doc = " Trace Datapath responses"]
pub use self::_ocsd_datapath_resp_t as ocsd_datapath_resp_t;
#[doc = "< None data operation on data path. (EOT etc.)"]
pub const _rcdtl_rawframe_elem_t_OCSD_FRM_NONE: _rcdtl_rawframe_elem_t = 0;
#[doc = "< Raw packed frame data"]
pub const _rcdtl_rawframe_elem_t_OCSD_FRM_PACKED: _rcdtl_rawframe_elem_t = 1;
#[doc = "< HSYNC data"]
pub const _rcdtl_rawframe_elem_t_OCSD_FRM_HSYNC: _rcdtl_rawframe_elem_t = 2;
#[doc = "< Frame Sync Data"]
pub const _rcdtl_rawframe_elem_t_OCSD_FRM_FSYNC: _rcdtl_rawframe_elem_t = 3;
#[doc = "< unpacked data for ID"]
pub const _rcdtl_rawframe_elem_t_OCSD_FRM_ID_DATA: _rcdtl_rawframe_elem_t = 4;
#[doc = " Raw frame element data types\nData blocks types output from ITrcRawFrameIn."]
pub type _rcdtl_rawframe_elem_t = ::std::os::raw::c_uint;
#[doc = " Raw frame element data types\nData blocks types output from ITrcRawFrameIn."]
pub use self::_rcdtl_rawframe_elem_t as ocsd_rawframe_elem_t;
#[doc = "< input source is frame formatted."]
pub const _ocsd_dcd_tree_src_t_OCSD_TRC_SRC_FRAME_FORMATTED: _ocsd_dcd_tree_src_t = 0;
#[doc = "< input source is from a single protocol generator."]
pub const _ocsd_dcd_tree_src_t_OCSD_TRC_SRC_SINGLE: _ocsd_dcd_tree_src_t = 1;
#[doc = " Indicates if the trace source will be frame formatted or a single protocol source.\nUsed in decode tree creation and configuration code."]
pub type _ocsd_dcd_tree_src_t = ::std::os::raw::c_uint;
#[doc = " Indicates if the trace source will be frame formatted or a single protocol source.\nUsed in decode tree creation and configuration code."]
pub use self::_ocsd_dcd_tree_src_t as ocsd_dcd_tree_src_t;
#[doc = "< unknown architecture"]
pub const _ocsd_arch_version_ARCH_UNKNOWN: _ocsd_arch_version = 0;
#[doc = "< None ARM, custom architecture"]
pub const _ocsd_arch_version_ARCH_CUSTOM: _ocsd_arch_version = 1;
#[doc = "< V7 architecture"]
pub const _ocsd_arch_version_ARCH_V7: _ocsd_arch_version = 1792;
#[doc = "< V8 architecture"]
pub const _ocsd_arch_version_ARCH_V8: _ocsd_arch_version = 2048;
#[doc = "< V8.3 architecture"]
pub const _ocsd_arch_version_ARCH_V8r3: _ocsd_arch_version = 2051;
#[doc = "< Min v8r3 plus additional AA64 PE features"]
pub const _ocsd_arch_version_ARCH_AA64: _ocsd_arch_version = 2148;
pub const _ocsd_arch_version_ARCH_V8_max: _ocsd_arch_version = 2148;
#[doc = " Core Architecture Version"]
pub type _ocsd_arch_version = ::std::os::raw::c_uint;
#[doc = " Core Architecture Version"]
pub use self::_ocsd_arch_version as ocsd_arch_version_t;
#[doc = "< Unknown profile"]
pub const _ocsd_core_profile_profile_Unknown: _ocsd_core_profile = 0;
#[doc = "< Cortex-M profile"]
pub const _ocsd_core_profile_profile_CortexM: _ocsd_core_profile = 1;
#[doc = "< Cortex-R profile"]
pub const _ocsd_core_profile_profile_CortexR: _ocsd_core_profile = 2;
#[doc = "< Cortex-A profile"]
pub const _ocsd_core_profile_profile_CortexA: _ocsd_core_profile = 3;
#[doc = "< None ARM, custom arch profile"]
pub const _ocsd_core_profile_profile_Custom: _ocsd_core_profile = 4;
#[doc = " Core Profile"]
pub type _ocsd_core_profile = ::std::os::raw::c_uint;
#[doc = " Core Profile"]
pub use self::_ocsd_core_profile as ocsd_core_profile_t;
#[doc = " Combined architecture and profile descriptor for a core"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_arch_profile_t {
    #[doc = "< core architecture"]
    pub arch: ocsd_arch_version_t,
    #[doc = "< core profile"]
    pub profile: ocsd_core_profile_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_arch_profile_t"][::std::mem::size_of::<_ocsd_arch_profile_t>() - 8usize];
    ["Alignment of _ocsd_arch_profile_t"][::std::mem::align_of::<_ocsd_arch_profile_t>() - 4usize];
    ["Offset of field: _ocsd_arch_profile_t::arch"]
        [::std::mem::offset_of!(_ocsd_arch_profile_t, arch) - 0usize];
    ["Offset of field: _ocsd_arch_profile_t::profile"]
        [::std::mem::offset_of!(_ocsd_arch_profile_t, profile) - 4usize];
};
#[doc = " Combined architecture and profile descriptor for a core"]
pub type ocsd_arch_profile_t = _ocsd_arch_profile_t;
pub type ocsd_vaddr_t = u64;
#[doc = "< V7 ARM 32, V8 AArch32"]
pub const _ocsd_isa_ocsd_isa_arm: _ocsd_isa = 0;
#[doc = "< Thumb2 -> 16/32 bit instructions"]
pub const _ocsd_isa_ocsd_isa_thumb2: _ocsd_isa = 1;
#[doc = "< V8 AArch64"]
pub const _ocsd_isa_ocsd_isa_aarch64: _ocsd_isa = 2;
#[doc = "< Thumb EE - unsupported"]
pub const _ocsd_isa_ocsd_isa_tee: _ocsd_isa = 3;
#[doc = "< Jazelle - unsupported in trace"]
pub const _ocsd_isa_ocsd_isa_jazelle: _ocsd_isa = 4;
#[doc = "< Instruction set - custom arch decoder"]
pub const _ocsd_isa_ocsd_isa_custom: _ocsd_isa = 5;
#[doc = "< ISA not yet known"]
pub const _ocsd_isa_ocsd_isa_unknown: _ocsd_isa = 6;
#[doc = " Instruction Set Architecture type\n"]
pub type _ocsd_isa = ::std::os::raw::c_uint;
#[doc = " Instruction Set Architecture type\n"]
pub use self::_ocsd_isa as ocsd_isa;
#[doc = "< Core is in secure state"]
pub const _ocsd_sec_level_ocsd_sec_secure: _ocsd_sec_level = 0;
#[doc = "< Core is in non-secure state"]
pub const _ocsd_sec_level_ocsd_sec_nonsecure: _ocsd_sec_level = 1;
#[doc = "< PE FEAT_RME: Core is in root state."]
pub const _ocsd_sec_level_ocsd_sec_root: _ocsd_sec_level = 2;
#[doc = "< PE FEAT_RME: Core is in realm state."]
pub const _ocsd_sec_level_ocsd_sec_realm: _ocsd_sec_level = 3;
#[doc = " Security level type"]
pub type _ocsd_sec_level = ::std::os::raw::c_uint;
#[doc = " Security level type"]
pub use self::_ocsd_sec_level as ocsd_sec_level;
#[doc = "< EL unknown / unsupported in trace"]
pub const _ocsd_ex_level_ocsd_EL_unknown: _ocsd_ex_level = -1;
#[doc = "< EL0"]
pub const _ocsd_ex_level_ocsd_EL0: _ocsd_ex_level = 0;
#[doc = "< EL1"]
pub const _ocsd_ex_level_ocsd_EL1: _ocsd_ex_level = 1;
#[doc = "< EL2"]
pub const _ocsd_ex_level_ocsd_EL2: _ocsd_ex_level = 2;
#[doc = "< EL3"]
pub const _ocsd_ex_level_ocsd_EL3: _ocsd_ex_level = 3;
#[doc = " Exception level type"]
pub type _ocsd_ex_level = ::std::os::raw::c_int;
#[doc = " Exception level type"]
pub use self::_ocsd_ex_level as ocsd_ex_level;
#[doc = "< Other instruction - not significant for waypoints."]
pub const _ocsd_instr_type_OCSD_INSTR_OTHER: _ocsd_instr_type = 0;
#[doc = "< Immediate Branch instruction"]
pub const _ocsd_instr_type_OCSD_INSTR_BR: _ocsd_instr_type = 1;
#[doc = "< Indirect Branch instruction"]
pub const _ocsd_instr_type_OCSD_INSTR_BR_INDIRECT: _ocsd_instr_type = 2;
#[doc = "< Barrier : ISB instruction"]
pub const _ocsd_instr_type_OCSD_INSTR_ISB: _ocsd_instr_type = 3;
#[doc = "< Barrier : DSB or DMB instruction"]
pub const _ocsd_instr_type_OCSD_INSTR_DSB_DMB: _ocsd_instr_type = 4;
#[doc = "< WFI or WFE traced as direct branch"]
pub const _ocsd_instr_type_OCSD_INSTR_WFI_WFE: _ocsd_instr_type = 5;
#[doc = "< PE Arch feature FEAT_TME - TSTART instruction"]
pub const _ocsd_instr_type_OCSD_INSTR_TSTART: _ocsd_instr_type = 6;
#[doc = " instruction types - significant for waypoint calculations"]
pub type _ocsd_instr_type = ::std::os::raw::c_uint;
#[doc = " instruction types - significant for waypoint calculations"]
pub use self::_ocsd_instr_type as ocsd_instr_type;
#[doc = "< no subtype set"]
pub const _ocsd_instr_subtype_OCSD_S_INSTR_NONE: _ocsd_instr_subtype = 0;
#[doc = "< branch with link"]
pub const _ocsd_instr_subtype_OCSD_S_INSTR_BR_LINK: _ocsd_instr_subtype = 1;
#[doc = "< v8 ret instruction - subtype of BR_INDIRECT"]
pub const _ocsd_instr_subtype_OCSD_S_INSTR_V8_RET: _ocsd_instr_subtype = 2;
#[doc = "< v8 eret instruction - subtype of BR_INDIRECT"]
pub const _ocsd_instr_subtype_OCSD_S_INSTR_V8_ERET: _ocsd_instr_subtype = 3;
#[doc = "< v7 instruction which could imply return e.g. MOV PC, LR; POP { ,pc}"]
pub const _ocsd_instr_subtype_OCSD_S_INSTR_V7_IMPLIED_RET: _ocsd_instr_subtype = 4;
#[doc = " instruction sub types - addiitonal information passed to the output packets\nfor trace analysis tools."]
pub type _ocsd_instr_subtype = ::std::os::raw::c_uint;
#[doc = " instruction sub types - addiitonal information passed to the output packets\nfor trace analysis tools."]
pub use self::_ocsd_instr_subtype as ocsd_instr_subtype;
#[doc = " Instruction decode request structure.\n\n   Used in IInstrDecode  interface.\n\n   Caller fills in the input: information, callee then fills in the decoder: information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_instr_info {
    #[doc = "< input: Core Arch and profile"]
    pub pe_type: ocsd_arch_profile_t,
    #[doc = "< Input: Current ISA."]
    pub isa: ocsd_isa,
    #[doc = "< Input: Instruction address."]
    pub instr_addr: ocsd_vaddr_t,
    #[doc = "< Input: Opcode at address. 16 bit opcodes will use MS 16bits of parameter."]
    pub opcode: u32,
    #[doc = "< Input: DMB and DSB are waypoints"]
    pub dsb_dmb_waypoints: u8,
    #[doc = "< Input: WFI, WFE classed as direct branches"]
    pub wfi_wfe_branch: u8,
    #[doc = "< Decoder: Current instruction type."]
    pub type_: ocsd_instr_type,
    #[doc = "< Decoder: Calculated address of branch instrcution (direct branches only)"]
    pub branch_addr: ocsd_vaddr_t,
    #[doc = "< Decoder: ISA for next intruction."]
    pub next_isa: ocsd_isa,
    #[doc = "< Decoder : size of the decoded instruction"]
    pub instr_size: u8,
    #[doc = "< Decoder : set to 1 if this instruction is conditional"]
    pub is_conditional: u8,
    #[doc = "< Decoder : is a branch with link instruction"]
    pub is_link: u8,
    #[doc = "< Decoder : return number of following instructions set with conditions by this Thumb IT instruction"]
    pub thumb_it_conditions: u8,
    #[doc = "< Decoder : current instruction sub-type if known"]
    pub sub_type: ocsd_instr_subtype,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_instr_info"][::std::mem::size_of::<_ocsd_instr_info>() - 64usize];
    ["Alignment of _ocsd_instr_info"][::std::mem::align_of::<_ocsd_instr_info>() - 8usize];
    ["Offset of field: _ocsd_instr_info::pe_type"]
        [::std::mem::offset_of!(_ocsd_instr_info, pe_type) - 0usize];
    ["Offset of field: _ocsd_instr_info::isa"]
        [::std::mem::offset_of!(_ocsd_instr_info, isa) - 8usize];
    ["Offset of field: _ocsd_instr_info::instr_addr"]
        [::std::mem::offset_of!(_ocsd_instr_info, instr_addr) - 16usize];
    ["Offset of field: _ocsd_instr_info::opcode"]
        [::std::mem::offset_of!(_ocsd_instr_info, opcode) - 24usize];
    ["Offset of field: _ocsd_instr_info::dsb_dmb_waypoints"]
        [::std::mem::offset_of!(_ocsd_instr_info, dsb_dmb_waypoints) - 28usize];
    ["Offset of field: _ocsd_instr_info::wfi_wfe_branch"]
        [::std::mem::offset_of!(_ocsd_instr_info, wfi_wfe_branch) - 29usize];
    ["Offset of field: _ocsd_instr_info::type_"]
        [::std::mem::offset_of!(_ocsd_instr_info, type_) - 32usize];
    ["Offset of field: _ocsd_instr_info::branch_addr"]
        [::std::mem::offset_of!(_ocsd_instr_info, branch_addr) - 40usize];
    ["Offset of field: _ocsd_instr_info::next_isa"]
        [::std::mem::offset_of!(_ocsd_instr_info, next_isa) - 48usize];
    ["Offset of field: _ocsd_instr_info::instr_size"]
        [::std::mem::offset_of!(_ocsd_instr_info, instr_size) - 52usize];
    ["Offset of field: _ocsd_instr_info::is_conditional"]
        [::std::mem::offset_of!(_ocsd_instr_info, is_conditional) - 53usize];
    ["Offset of field: _ocsd_instr_info::is_link"]
        [::std::mem::offset_of!(_ocsd_instr_info, is_link) - 54usize];
    ["Offset of field: _ocsd_instr_info::thumb_it_conditions"]
        [::std::mem::offset_of!(_ocsd_instr_info, thumb_it_conditions) - 55usize];
    ["Offset of field: _ocsd_instr_info::sub_type"]
        [::std::mem::offset_of!(_ocsd_instr_info, sub_type) - 56usize];
};
#[doc = " Instruction decode request structure.\n\n   Used in IInstrDecode  interface.\n\n   Caller fills in the input: information, callee then fills in the decoder: information."]
pub type ocsd_instr_info = _ocsd_instr_info;
#[doc = " Core(PE) context structure\nrecords current security state, exception level, VMID and ContextID for core."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_pe_context {
    #[doc = "< security state"]
    pub security_level: ocsd_sec_level,
    #[doc = "< exception level"]
    pub exception_level: ocsd_ex_level,
    #[doc = "< context ID"]
    pub context_id: u32,
    #[doc = "< VMID"]
    pub vmid: u32,
    pub __bindgen_anon_1: _ocsd_pe_context__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_pe_context__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_pe_context__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_pe_context__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_pe_context__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_pe_context__bindgen_ty_1>() - 4usize];
};
impl _ocsd_pe_context__bindgen_ty_1 {
    #[inline]
    pub fn bits64(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bits64(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bits64_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bits64_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ctxt_id_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctxt_id_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ctxt_id_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ctxt_id_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vmid_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vmid_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vmid_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vmid_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn el_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_el_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn el_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_el_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bits64: u32,
        ctxt_id_valid: u32,
        vmid_valid: u32,
        el_valid: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bits64: u32 = unsafe { ::std::mem::transmute(bits64) };
            bits64 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ctxt_id_valid: u32 = unsafe { ::std::mem::transmute(ctxt_id_valid) };
            ctxt_id_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let vmid_valid: u32 = unsafe { ::std::mem::transmute(vmid_valid) };
            vmid_valid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let el_valid: u32 = unsafe { ::std::mem::transmute(el_valid) };
            el_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_pe_context"][::std::mem::size_of::<_ocsd_pe_context>() - 20usize];
    ["Alignment of _ocsd_pe_context"][::std::mem::align_of::<_ocsd_pe_context>() - 4usize];
    ["Offset of field: _ocsd_pe_context::security_level"]
        [::std::mem::offset_of!(_ocsd_pe_context, security_level) - 0usize];
    ["Offset of field: _ocsd_pe_context::exception_level"]
        [::std::mem::offset_of!(_ocsd_pe_context, exception_level) - 4usize];
    ["Offset of field: _ocsd_pe_context::context_id"]
        [::std::mem::offset_of!(_ocsd_pe_context, context_id) - 8usize];
    ["Offset of field: _ocsd_pe_context::vmid"]
        [::std::mem::offset_of!(_ocsd_pe_context, vmid) - 12usize];
};
#[doc = " Core(PE) context structure\nrecords current security state, exception level, VMID and ContextID for core."]
pub type ocsd_pe_context = _ocsd_pe_context;
#[doc = "< Mem space unknown / not yet set"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_NONE: _ocsd_mem_space_acc_t = 0;
#[doc = "< Secure EL1/0"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_EL1S: _ocsd_mem_space_acc_t = 1;
#[doc = "< Non Secure EL1/0"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_EL1N: _ocsd_mem_space_acc_t = 2;
#[doc = "< Non Secure EL2"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_EL2: _ocsd_mem_space_acc_t = 4;
#[doc = "< Secure EL3"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_EL3: _ocsd_mem_space_acc_t = 8;
#[doc = "< Secure EL2"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_EL2S: _ocsd_mem_space_acc_t = 16;
#[doc = "< Realm EL1/0"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_EL1R: _ocsd_mem_space_acc_t = 32;
#[doc = "< Realm EL2"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_EL2R: _ocsd_mem_space_acc_t = 64;
#[doc = "< Root"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_ROOT: _ocsd_mem_space_acc_t = 128;
#[doc = "< Any Secure"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_S: _ocsd_mem_space_acc_t = 25;
#[doc = "< Any Non Secure"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_N: _ocsd_mem_space_acc_t = 6;
#[doc = "< Any Realm"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_R: _ocsd_mem_space_acc_t = 96;
#[doc = "< Any sec level / EL - live system use current EL + sec state"]
pub const _ocsd_mem_space_acc_t_OCSD_MEM_SPACE_ANY: _ocsd_mem_space_acc_t = 255;
#[doc = " memory space bitfield enum for available security states and exception levels used\nwhen accessing memory."]
pub type _ocsd_mem_space_acc_t = ::std::os::raw::c_uint;
#[doc = " memory space bitfield enum for available security states and exception levels used\nwhen accessing memory."]
pub use self::_ocsd_mem_space_acc_t as ocsd_mem_space_acc_t;
#[doc = " Callback function definition for callback function memory accessor type.\n\n When using callback memory accessor, the decoder will call this function to obtain the\n memory at the address for the current opcodes. The memory space will represent the current\n exception level and security context of the traced code.\n\n Return the number of bytes read, which can be less than the amount requested if this would take the\n access address outside the range of addresses defined when this callback was registered with the decoder.\n\n Return 0 bytes if start address out of covered range, or memory space is not one of those defined as supported\n when the callback was registered.\n\n @param p_context : opaque context pointer set by callback client.\n @param address : start address of memory to be accessed\n @param mem_space : memory space of accessed memory (current EL & security state)\n @param reqBytes : number of bytes required\n @param *byteBuffer : buffer for data.\n\n @return uint32_t  : Number of bytes actually read, or 0 for access error."]
pub type Fn_MemAcc_CB = ::std::option::Option<
    unsafe extern "C" fn(
        p_context: *const ::std::os::raw::c_void,
        address: ocsd_vaddr_t,
        mem_space: ocsd_mem_space_acc_t,
        reqBytes: u32,
        byteBuffer: *mut u8,
    ) -> u32,
>;
#[doc = " Callback function definition for callback function memory accessor type.\n\n When using callback memory accessor, the decoder will call this function to obtain the\n memory at the address for the current opcodes. The memory space will represent the current\n exception level and security context of the traced code.\n\n Return the number of bytes read, which can be less than the amount requested if this would take the\n access address outside the range of addresses defined when this callback was registered with the decoder.\n\n Return 0 bytes if start address out of covered range, or memory space is not one of those defined as supported\n when the callback was registered.\n\n @param p_context : opaque context pointer set by callback client.\n @param address : start address of memory to be accessed\n @param mem_space : memory space of accessed memory (current EL & security state)\n @param trcID : Trace ID for source of trace - allow CB to client to associate mem req with source cpu.\n @param reqBytes : number of bytes required\n @param *byteBuffer : buffer for data.\n\n @return uint32_t  : Number of bytes actually read, or 0 for access error."]
pub type Fn_MemAccID_CB = ::std::option::Option<
    unsafe extern "C" fn(
        p_context: *const ::std::os::raw::c_void,
        address: ocsd_vaddr_t,
        mem_space: ocsd_mem_space_acc_t,
        trcID: u8,
        reqBytes: u32,
        byteBuffer: *mut u8,
    ) -> u32,
>;
#[doc = " memory region type for adding multi-region binary files to memory access interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_file_mem_region {
    #[doc = "< Offset from start of file for memory region"]
    pub file_offset: usize,
    #[doc = "< Start address of memory region"]
    pub start_address: ocsd_vaddr_t,
    #[doc = "< size in bytes of memory region"]
    pub region_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_file_mem_region"][::std::mem::size_of::<_ocsd_file_mem_region>() - 24usize];
    ["Alignment of _ocsd_file_mem_region"]
        [::std::mem::align_of::<_ocsd_file_mem_region>() - 8usize];
    ["Offset of field: _ocsd_file_mem_region::file_offset"]
        [::std::mem::offset_of!(_ocsd_file_mem_region, file_offset) - 0usize];
    ["Offset of field: _ocsd_file_mem_region::start_address"]
        [::std::mem::offset_of!(_ocsd_file_mem_region, start_address) - 8usize];
    ["Offset of field: _ocsd_file_mem_region::region_size"]
        [::std::mem::offset_of!(_ocsd_file_mem_region, region_size) - 16usize];
};
#[doc = " memory region type for adding multi-region binary files to memory access interface"]
pub type ocsd_file_mem_region_t = _ocsd_file_mem_region;
#[doc = "< Protocol unknown"]
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_UNKNOWN: _ocsd_trace_protocol_t = 0;
#[doc = "< ETMV3 instruction and data trace protocol decoder."]
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_ETMV3: _ocsd_trace_protocol_t = 1;
#[doc = "< ETMV4 instruction trace protocol decoder."]
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_ETMV4I: _ocsd_trace_protocol_t = 2;
#[doc = "< ETMV4 data trace protocol decoder."]
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_ETMV4D: _ocsd_trace_protocol_t = 3;
#[doc = "< PTM program flow instruction trace protocol decoder."]
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_PTM: _ocsd_trace_protocol_t = 4;
#[doc = "< STM system trace protocol decoder."]
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_STM: _ocsd_trace_protocol_t = 5;
#[doc = "< ETE trace protocol decoder"]
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_ETE: _ocsd_trace_protocol_t = 6;
#[doc = "< Invalid protocol - built-in protocol types end marker"]
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_BUILTIN_END: _ocsd_trace_protocol_t = 7;
#[doc = "< Values from this onwards are assigned to external registered decoders"]
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_CUSTOM_0: _ocsd_trace_protocol_t = 100;
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_CUSTOM_1: _ocsd_trace_protocol_t = 101;
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_CUSTOM_2: _ocsd_trace_protocol_t = 102;
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_CUSTOM_3: _ocsd_trace_protocol_t = 103;
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_CUSTOM_4: _ocsd_trace_protocol_t = 104;
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_CUSTOM_5: _ocsd_trace_protocol_t = 105;
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_CUSTOM_6: _ocsd_trace_protocol_t = 106;
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_CUSTOM_7: _ocsd_trace_protocol_t = 107;
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_CUSTOM_8: _ocsd_trace_protocol_t = 108;
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_CUSTOM_9: _ocsd_trace_protocol_t = 109;
#[doc = "< Invalid protocol - protocol types end marker"]
pub const _ocsd_trace_protocol_t_OCSD_PROTOCOL_END: _ocsd_trace_protocol_t = 110;
#[doc = " Trace Protocol Builtin Types + extern"]
pub type _ocsd_trace_protocol_t = ::std::os::raw::c_uint;
#[doc = " Trace Protocol Builtin Types + extern"]
pub use self::_ocsd_trace_protocol_t as ocsd_trace_protocol_t;
#[doc = " @name Software Trace Packets Info\n\nContains the information for the generic software trace output packet.\n\nSoftware trace packet master and channel data.\nPayload info:\nsize - packet payload size in bits;\nmarker - if this packet has a marker/flag\ntimestamp - if this packet has a timestamp associated\nnumber of packets - packet processor can optionally correlate identically\nsized packets on the same master / channel to be output as a single generic packet\n\nPayload output as separate LE buffer, of sufficient bytes to hold all the packets.\n@{"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ocsd_swt_info {
    pub swt_master_id: u16,
    pub swt_channel_id: u16,
    pub __bindgen_anon_1: _ocsd_swt_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ocsd_swt_info__bindgen_ty_1 {
    pub __bindgen_anon_1: _ocsd_swt_info__bindgen_ty_1__bindgen_ty_1,
    pub swt_flag_bits: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_swt_info__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_swt_info__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_swt_info__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_swt_info__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_swt_info__bindgen_ty_1__bindgen_ty_1>() - 4usize];
};
impl _ocsd_swt_info__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn swt_payload_pkt_bitsize(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_swt_payload_pkt_bitsize(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swt_payload_pkt_bitsize_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swt_payload_pkt_bitsize_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swt_payload_num_packets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_swt_payload_num_packets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swt_payload_num_packets_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swt_payload_num_packets_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swt_marker_packet(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swt_marker_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swt_marker_packet_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swt_marker_packet_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swt_has_timestamp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swt_has_timestamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swt_has_timestamp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swt_has_timestamp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swt_marker_first(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swt_marker_first(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swt_marker_first_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swt_marker_first_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swt_master_err(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swt_master_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swt_master_err_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swt_master_err_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swt_global_err(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swt_global_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swt_global_err_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swt_global_err_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swt_trigger_event(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swt_trigger_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swt_trigger_event_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swt_trigger_event_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swt_frequency(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swt_frequency(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swt_frequency_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swt_frequency_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn swt_id_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swt_id_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn swt_id_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_swt_id_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        swt_payload_pkt_bitsize: u32,
        swt_payload_num_packets: u32,
        swt_marker_packet: u32,
        swt_has_timestamp: u32,
        swt_marker_first: u32,
        swt_master_err: u32,
        swt_global_err: u32,
        swt_trigger_event: u32,
        swt_frequency: u32,
        swt_id_valid: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let swt_payload_pkt_bitsize: u32 =
                unsafe { ::std::mem::transmute(swt_payload_pkt_bitsize) };
            swt_payload_pkt_bitsize as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let swt_payload_num_packets: u32 =
                unsafe { ::std::mem::transmute(swt_payload_num_packets) };
            swt_payload_num_packets as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let swt_marker_packet: u32 = unsafe { ::std::mem::transmute(swt_marker_packet) };
            swt_marker_packet as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let swt_has_timestamp: u32 = unsafe { ::std::mem::transmute(swt_has_timestamp) };
            swt_has_timestamp as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let swt_marker_first: u32 = unsafe { ::std::mem::transmute(swt_marker_first) };
            swt_marker_first as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let swt_master_err: u32 = unsafe { ::std::mem::transmute(swt_master_err) };
            swt_master_err as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let swt_global_err: u32 = unsafe { ::std::mem::transmute(swt_global_err) };
            swt_global_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let swt_trigger_event: u32 = unsafe { ::std::mem::transmute(swt_trigger_event) };
            swt_trigger_event as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let swt_frequency: u32 = unsafe { ::std::mem::transmute(swt_frequency) };
            swt_frequency as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let swt_id_valid: u32 = unsafe { ::std::mem::transmute(swt_id_valid) };
            swt_id_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_swt_info__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_swt_info__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_swt_info__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_swt_info__bindgen_ty_1>() - 4usize];
    ["Offset of field: _ocsd_swt_info__bindgen_ty_1::swt_flag_bits"]
        [::std::mem::offset_of!(_ocsd_swt_info__bindgen_ty_1, swt_flag_bits) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_swt_info"][::std::mem::size_of::<_ocsd_swt_info>() - 8usize];
    ["Alignment of _ocsd_swt_info"][::std::mem::align_of::<_ocsd_swt_info>() - 4usize];
    ["Offset of field: _ocsd_swt_info::swt_master_id"]
        [::std::mem::offset_of!(_ocsd_swt_info, swt_master_id) - 0usize];
    ["Offset of field: _ocsd_swt_info::swt_channel_id"]
        [::std::mem::offset_of!(_ocsd_swt_info, swt_channel_id) - 2usize];
};
#[doc = " @name Software Trace Packets Info\n\nContains the information for the generic software trace output packet.\n\nSoftware trace packet master and channel data.\nPayload info:\nsize - packet payload size in bits;\nmarker - if this packet has a marker/flag\ntimestamp - if this packet has a timestamp associated\nnumber of packets - packet processor can optionally correlate identically\nsized packets on the same master / channel to be output as a single generic packet\n\nPayload output as separate LE buffer, of sufficient bytes to hold all the packets.\n@{"]
pub type ocsd_swt_info_t = _ocsd_swt_info;
#[doc = " @name Demux Statistics\n\nContains statistics for the CoreSight frame demultiplexor.\n\nCounts total bytes sent to decoders registered against a trace ID, bytes in the input stream that are\nassociated with a trace ID that has no registered decoder, and frame bytes that are not trace data, but\nare used to decode the frames - ID bytes, sync bytes etc.\n@{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_demux_stats {
    #[doc = "< number of bytes associated with an ID that has a registered decoder"]
    pub valid_id_bytes: u64,
    #[doc = "< number of bytes associated with an ID that has no decoder"]
    pub no_id_bytes: u64,
    #[doc = "< number of bytes associated with reserved IDs"]
    pub reserved_id_bytes: u64,
    #[doc = "< bytes processed before ID seen in input frames"]
    pub unknown_id_bytes: u64,
    #[doc = "< number of non-data bytes used for frame de-mux - ID bytes, sync etc"]
    pub frame_bytes: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_demux_stats"][::std::mem::size_of::<_ocsd_demux_stats>() - 40usize];
    ["Alignment of _ocsd_demux_stats"][::std::mem::align_of::<_ocsd_demux_stats>() - 8usize];
    ["Offset of field: _ocsd_demux_stats::valid_id_bytes"]
        [::std::mem::offset_of!(_ocsd_demux_stats, valid_id_bytes) - 0usize];
    ["Offset of field: _ocsd_demux_stats::no_id_bytes"]
        [::std::mem::offset_of!(_ocsd_demux_stats, no_id_bytes) - 8usize];
    ["Offset of field: _ocsd_demux_stats::reserved_id_bytes"]
        [::std::mem::offset_of!(_ocsd_demux_stats, reserved_id_bytes) - 16usize];
    ["Offset of field: _ocsd_demux_stats::unknown_id_bytes"]
        [::std::mem::offset_of!(_ocsd_demux_stats, unknown_id_bytes) - 24usize];
    ["Offset of field: _ocsd_demux_stats::frame_bytes"]
        [::std::mem::offset_of!(_ocsd_demux_stats, frame_bytes) - 32usize];
};
#[doc = " @name Demux Statistics\n\nContains statistics for the CoreSight frame demultiplexor.\n\nCounts total bytes sent to decoders registered against a trace ID, bytes in the input stream that are\nassociated with a trace ID that has no registered decoder, and frame bytes that are not trace data, but\nare used to decode the frames - ID bytes, sync bytes etc.\n@{"]
pub type ocsd_demux_stats_t = _ocsd_demux_stats;
#[doc = " @name Decode statistics\n\nContains statistics for bytes decoded by the packet decoder, if statistics are supported.\n\nStats block instantiated in the base class - derived protocol specific decoder must initialise and\nuse as required.\n\nThe single channel block contains the stats for the requested channel via the API call.\n\nThe global demux block contains the totals for all channels and non-data bytes used in CoreSight\nframe demux. This block will show identical data for every requested channel via the API.\n\n@{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_decode_stats {
    #[doc = "< library version number"]
    pub version: u32,
    #[doc = "< revision number - defines the structure version for the stats."]
    pub revision: u16,
    #[doc = "< total bytes processed for this channel"]
    pub channel_total: u64,
    #[doc = "< number of unsynced bytes processed on this channel"]
    pub channel_unsynced: u64,
    #[doc = "< number of bad packet header errors"]
    pub bad_header_errs: u32,
    #[doc = "< number of bad packet sequence errors"]
    pub bad_sequence_errs: u32,
    #[doc = "< global demux stats block"]
    pub demux: ocsd_demux_stats_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_decode_stats"][::std::mem::size_of::<_ocsd_decode_stats>() - 72usize];
    ["Alignment of _ocsd_decode_stats"][::std::mem::align_of::<_ocsd_decode_stats>() - 8usize];
    ["Offset of field: _ocsd_decode_stats::version"]
        [::std::mem::offset_of!(_ocsd_decode_stats, version) - 0usize];
    ["Offset of field: _ocsd_decode_stats::revision"]
        [::std::mem::offset_of!(_ocsd_decode_stats, revision) - 4usize];
    ["Offset of field: _ocsd_decode_stats::channel_total"]
        [::std::mem::offset_of!(_ocsd_decode_stats, channel_total) - 8usize];
    ["Offset of field: _ocsd_decode_stats::channel_unsynced"]
        [::std::mem::offset_of!(_ocsd_decode_stats, channel_unsynced) - 16usize];
    ["Offset of field: _ocsd_decode_stats::bad_header_errs"]
        [::std::mem::offset_of!(_ocsd_decode_stats, bad_header_errs) - 24usize];
    ["Offset of field: _ocsd_decode_stats::bad_sequence_errs"]
        [::std::mem::offset_of!(_ocsd_decode_stats, bad_sequence_errs) - 28usize];
    ["Offset of field: _ocsd_decode_stats::demux"]
        [::std::mem::offset_of!(_ocsd_decode_stats, demux) - 32usize];
};
#[doc = " @name Decode statistics\n\nContains statistics for bytes decoded by the packet decoder, if statistics are supported.\n\nStats block instantiated in the base class - derived protocol specific decoder must initialise and\nuse as required.\n\nThe single channel block contains the stats for the requested channel via the API call.\n\nThe global demux block contains the totals for all channels and non-data bytes used in CoreSight\nframe demux. This block will show identical data for every requested channel via the API.\n\n@{"]
pub type ocsd_decode_stats_t = _ocsd_decode_stats;
#[doc = "< Unknown trace element - default value or indicate error in stream to client"]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_UNKNOWN: _ocsd_gen_trc_elem_t = 0;
#[doc = "< Waiting for sync - either at start of decode, or after overflow / bad packet"]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_NO_SYNC: _ocsd_gen_trc_elem_t = 1;
#[doc = "< Start of trace - beginning of elements or restart after discontinuity (overflow, trace filtering)."]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_TRACE_ON: _ocsd_gen_trc_elem_t = 2;
#[doc = "< end of the available trace in the buffer."]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_EO_TRACE: _ocsd_gen_trc_elem_t = 3;
#[doc = "< PE status update / change (arch, ctxtid, vmid etc)."]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_PE_CONTEXT: _ocsd_gen_trc_elem_t = 4;
#[doc = "< traced N consecutive instructions from addr (no intervening events or data elements), may have data assoc key"]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_INSTR_RANGE: _ocsd_gen_trc_elem_t = 5;
#[doc = "< traced N instructions in a range, but incomplete information as to program execution path from start to end of range"]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_I_RANGE_NOPATH: _ocsd_gen_trc_elem_t = 6;
#[doc = "< tracing in inaccessible memory area"]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_ADDR_NACC: _ocsd_gen_trc_elem_t = 7;
#[doc = "< address currently unknown - need address packet update"]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_ADDR_UNKNOWN: _ocsd_gen_trc_elem_t = 8;
#[doc = "< exception - start address may be exception target, end address may be preferred ret addr."]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_EXCEPTION: _ocsd_gen_trc_elem_t = 9;
#[doc = "< expection return"]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_EXCEPTION_RET: _ocsd_gen_trc_elem_t = 10;
#[doc = "< Timestamp - preceding elements happeded before this time."]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_TIMESTAMP: _ocsd_gen_trc_elem_t = 11;
#[doc = "< Cycle count - cycles since last cycle count value - associated with a preceding instruction range."]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_CYCLE_COUNT: _ocsd_gen_trc_elem_t = 12;
#[doc = "< Event - trigger or numbered event"]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_EVENT: _ocsd_gen_trc_elem_t = 13;
#[doc = "< Software trace packet - may contain data payload. STM / ITM hardware trace with channel protocol"]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_SWTRACE: _ocsd_gen_trc_elem_t = 14;
#[doc = "< Synchronisation marker - marks position in stream of an element that is output later."]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_SYNC_MARKER: _ocsd_gen_trc_elem_t = 15;
#[doc = "< Trace indication of transactional memory operations."]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_MEMTRANS: _ocsd_gen_trc_elem_t = 16;
#[doc = "< PE instrumentation trace - PE generated SW trace, application dependent protocol."]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_INSTRUMENTATION: _ocsd_gen_trc_elem_t = 17;
#[doc = "< Fully custom packet type - used by none-ARM architecture decoders"]
pub const _ocsd_gen_trc_elem_t_OCSD_GEN_TRC_ELEM_CUSTOM: _ocsd_gen_trc_elem_t = 18;
#[doc = "  Enum for generic element types"]
pub type _ocsd_gen_trc_elem_t = ::std::os::raw::c_uint;
#[doc = "  Enum for generic element types"]
pub use self::_ocsd_gen_trc_elem_t as ocsd_gen_trc_elem_t;
#[doc = "< Trace on at start of trace or filtering discontinuity"]
pub const _trace_on_reason_t_TRACE_ON_NORMAL: _trace_on_reason_t = 0;
#[doc = "< Trace on due to prior trace overflow discontinuity"]
pub const _trace_on_reason_t_TRACE_ON_OVERFLOW: _trace_on_reason_t = 1;
#[doc = "< Trace restarted due to debug exit"]
pub const _trace_on_reason_t_TRACE_ON_EX_DEBUG: _trace_on_reason_t = 2;
pub type _trace_on_reason_t = ::std::os::raw::c_uint;
pub use self::_trace_on_reason_t as trace_on_reason_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _trace_event_t {
    #[doc = "< event type - unknown (0) trigger (1), numbered event (2)"]
    pub ev_type: u16,
    #[doc = "< event number if numbered event type"]
    pub ev_number: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _trace_event_t"][::std::mem::size_of::<_trace_event_t>() - 4usize];
    ["Alignment of _trace_event_t"][::std::mem::align_of::<_trace_event_t>() - 2usize];
    ["Offset of field: _trace_event_t::ev_type"]
        [::std::mem::offset_of!(_trace_event_t, ev_type) - 0usize];
    ["Offset of field: _trace_event_t::ev_number"]
        [::std::mem::offset_of!(_trace_event_t, ev_number) - 2usize];
};
pub type trace_event_t = _trace_event_t;
#[doc = "< unknown /undefined"]
pub const _unsync_info_t_UNSYNC_UNKNOWN: _unsync_info_t = 0;
#[doc = "< decoder intialisation - start of trace."]
pub const _unsync_info_t_UNSYNC_INIT_DECODER: _unsync_info_t = 1;
#[doc = "< decoder reset."]
pub const _unsync_info_t_UNSYNC_RESET_DECODER: _unsync_info_t = 2;
#[doc = "< overflow packet - need to re-sync / end of trace after overflow."]
pub const _unsync_info_t_UNSYNC_OVERFLOW: _unsync_info_t = 3;
#[doc = "< specl trace discard - need to re-sync."]
pub const _unsync_info_t_UNSYNC_DISCARD: _unsync_info_t = 4;
#[doc = "< bad packet at input - resync to restart."]
pub const _unsync_info_t_UNSYNC_BAD_PACKET: _unsync_info_t = 5;
#[doc = "< bad program image - resync to restart."]
pub const _unsync_info_t_UNSYNC_BAD_IMAGE: _unsync_info_t = 6;
#[doc = "< end of trace - no additional info"]
pub const _unsync_info_t_UNSYNC_EOT: _unsync_info_t = 7;
pub type _unsync_info_t = ::std::os::raw::c_uint;
pub use self::_unsync_info_t as unsync_info_t;
#[doc = "< Marker for timestamp element"]
pub const _trace_sync_marker_t_ELEM_MARKER_TS: _trace_sync_marker_t = 0;
pub type _trace_sync_marker_t = ::std::os::raw::c_uint;
pub use self::_trace_sync_marker_t as trace_sync_marker_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _trace_marker_payload_t {
    #[doc = "< type of sync marker"]
    pub type_: trace_sync_marker_t,
    #[doc = "< sync marker value - usage depends on type"]
    pub value: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _trace_marker_payload_t"][::std::mem::size_of::<_trace_marker_payload_t>() - 8usize];
    ["Alignment of _trace_marker_payload_t"]
        [::std::mem::align_of::<_trace_marker_payload_t>() - 4usize];
    ["Offset of field: _trace_marker_payload_t::type_"]
        [::std::mem::offset_of!(_trace_marker_payload_t, type_) - 0usize];
    ["Offset of field: _trace_marker_payload_t::value"]
        [::std::mem::offset_of!(_trace_marker_payload_t, value) - 4usize];
};
pub type trace_marker_payload_t = _trace_marker_payload_t;
#[doc = "< Trace started while PE in transactional state"]
pub const _memtrans_t_OCSD_MEM_TRANS_TRACE_INIT: _memtrans_t = 0;
#[doc = "< Trace after this packet is part of a transactional memory sequence"]
pub const _memtrans_t_OCSD_MEM_TRANS_START: _memtrans_t = 1;
#[doc = "< Transactional memory sequence valid."]
pub const _memtrans_t_OCSD_MEM_TRANS_COMMIT: _memtrans_t = 2;
#[doc = "< Transactional memory sequence failed - operations since start of transaction have been unwound."]
pub const _memtrans_t_OCSD_MEM_TRANS_FAIL: _memtrans_t = 3;
pub type _memtrans_t = ::std::os::raw::c_uint;
pub use self::_memtrans_t as trace_memtrans_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _sw_ite_t {
    #[doc = "< exception level for PE sw instrumentation instruction"]
    pub el: u8,
    #[doc = "< payload for PE sw instrumentation instruction"]
    pub value: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _sw_ite_t"][::std::mem::size_of::<_sw_ite_t>() - 16usize];
    ["Alignment of _sw_ite_t"][::std::mem::align_of::<_sw_ite_t>() - 8usize];
    ["Offset of field: _sw_ite_t::el"][::std::mem::offset_of!(_sw_ite_t, el) - 0usize];
    ["Offset of field: _sw_ite_t::value"][::std::mem::offset_of!(_sw_ite_t, value) - 8usize];
};
pub type trace_sw_ite_t = _sw_ite_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ocsd_generic_trace_elem {
    #[doc = "< Element type - remaining data interpreted according to this value"]
    pub elem_type: ocsd_gen_trc_elem_t,
    #[doc = "< instruction set for executed instructions"]
    pub isa: ocsd_isa,
    #[doc = "< start address for instruction execution range / inaccessible code address / data address"]
    pub st_addr: ocsd_vaddr_t,
    #[doc = "< end address (exclusive) for instruction execution range."]
    pub en_addr: ocsd_vaddr_t,
    #[doc = "< PE Context"]
    pub context: ocsd_pe_context,
    #[doc = "< timestamp value for TS element type"]
    pub timestamp: u64,
    #[doc = "< cycle count for explicit cycle count element, or count for element with associated cycle count"]
    pub cycle_count: u32,
    #[doc = "< Last instruction type if instruction execution range"]
    pub last_i_type: ocsd_instr_type,
    #[doc = "< sub type for last instruction in range"]
    pub last_i_subtype: ocsd_instr_subtype,
    pub __bindgen_anon_1: _ocsd_generic_trace_elem__bindgen_ty_1,
    pub __bindgen_anon_2: _ocsd_generic_trace_elem__bindgen_ty_2,
    #[doc = "< pointer to extended data buffer (data trace, sw trace payload) / custom structure"]
    pub ptr_extended_data: *const ::std::os::raw::c_void,
}
#[doc = "! per element flags"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ocsd_generic_trace_elem__bindgen_ty_1 {
    pub __bindgen_anon_1: _ocsd_generic_trace_elem__bindgen_ty_1__bindgen_ty_1,
    pub flag_bits: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_generic_trace_elem__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_generic_trace_elem__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_generic_trace_elem__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_generic_trace_elem__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_generic_trace_elem__bindgen_ty_1__bindgen_ty_1>() - 4usize];
};
impl _ocsd_generic_trace_elem__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn last_instr_exec(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_instr_exec(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_instr_exec_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_last_instr_exec_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn last_instr_sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_last_instr_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_instr_sz_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_last_instr_sz_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_cc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_cc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_cc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_cc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cpu_freq_change(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_freq_change(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cpu_freq_change_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cpu_freq_change_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn excep_ret_addr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_excep_ret_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn excep_ret_addr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_excep_ret_addr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn excep_data_marker(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_excep_data_marker(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn excep_data_marker_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_excep_data_marker_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn extended_data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_extended_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn extended_data_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_extended_data_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_ts(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_ts_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_ts_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn last_instr_cond(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_instr_cond(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_instr_cond_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_last_instr_cond_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn excep_ret_addr_br_tgt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_excep_ret_addr_br_tgt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn excep_ret_addr_br_tgt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_excep_ret_addr_br_tgt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn excep_M_tail_chain(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_excep_M_tail_chain(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn excep_M_tail_chain_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_excep_M_tail_chain_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        last_instr_exec: u32,
        last_instr_sz: u32,
        has_cc: u32,
        cpu_freq_change: u32,
        excep_ret_addr: u32,
        excep_data_marker: u32,
        extended_data: u32,
        has_ts: u32,
        last_instr_cond: u32,
        excep_ret_addr_br_tgt: u32,
        excep_M_tail_chain: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let last_instr_exec: u32 = unsafe { ::std::mem::transmute(last_instr_exec) };
            last_instr_exec as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let last_instr_sz: u32 = unsafe { ::std::mem::transmute(last_instr_sz) };
            last_instr_sz as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_cc: u32 = unsafe { ::std::mem::transmute(has_cc) };
            has_cc as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cpu_freq_change: u32 = unsafe { ::std::mem::transmute(cpu_freq_change) };
            cpu_freq_change as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let excep_ret_addr: u32 = unsafe { ::std::mem::transmute(excep_ret_addr) };
            excep_ret_addr as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let excep_data_marker: u32 = unsafe { ::std::mem::transmute(excep_data_marker) };
            excep_data_marker as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let extended_data: u32 = unsafe { ::std::mem::transmute(extended_data) };
            extended_data as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let has_ts: u32 = unsafe { ::std::mem::transmute(has_ts) };
            has_ts as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let last_instr_cond: u32 = unsafe { ::std::mem::transmute(last_instr_cond) };
            last_instr_cond as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let excep_ret_addr_br_tgt: u32 =
                unsafe { ::std::mem::transmute(excep_ret_addr_br_tgt) };
            excep_ret_addr_br_tgt as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let excep_M_tail_chain: u32 = unsafe { ::std::mem::transmute(excep_M_tail_chain) };
            excep_M_tail_chain as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_generic_trace_elem__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_generic_trace_elem__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_generic_trace_elem__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_generic_trace_elem__bindgen_ty_1>() - 4usize];
    ["Offset of field: _ocsd_generic_trace_elem__bindgen_ty_1::flag_bits"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem__bindgen_ty_1, flag_bits) - 0usize];
};
#[doc = "! packet specific payloads"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ocsd_generic_trace_elem__bindgen_ty_2 {
    #[doc = "< exception number for exception type packets"]
    pub exception_number: u32,
    #[doc = "< Trace event - trigger etc"]
    pub trace_event: trace_event_t,
    #[doc = "< reason for the trace on packet"]
    pub trace_on_reason: trace_on_reason_t,
    #[doc = "< software trace packet info"]
    pub sw_trace_info: ocsd_swt_info_t,
    #[doc = "< number of instructions covered by range packet (for T32 this cannot be calculated from en-st/i_size)"]
    pub num_instr_range: u32,
    #[doc = "< additional information for unsync / end-of-trace packets."]
    pub unsync_eot_info: unsync_info_t,
    #[doc = "< marker element - sync later element to position in stream"]
    pub sync_marker: trace_marker_payload_t,
    #[doc = "< memory transaction packet - transaction event"]
    pub mem_trans: trace_memtrans_t,
    #[doc = "< PE sw instrumentation using FEAT_ITE"]
    pub sw_ite: trace_sw_ite_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_generic_trace_elem__bindgen_ty_2"]
        [::std::mem::size_of::<_ocsd_generic_trace_elem__bindgen_ty_2>() - 16usize];
    ["Alignment of _ocsd_generic_trace_elem__bindgen_ty_2"]
        [::std::mem::align_of::<_ocsd_generic_trace_elem__bindgen_ty_2>() - 8usize];
    ["Offset of field: _ocsd_generic_trace_elem__bindgen_ty_2::exception_number"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem__bindgen_ty_2, exception_number) - 0usize];
    ["Offset of field: _ocsd_generic_trace_elem__bindgen_ty_2::trace_event"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem__bindgen_ty_2, trace_event) - 0usize];
    ["Offset of field: _ocsd_generic_trace_elem__bindgen_ty_2::trace_on_reason"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem__bindgen_ty_2, trace_on_reason) - 0usize];
    ["Offset of field: _ocsd_generic_trace_elem__bindgen_ty_2::sw_trace_info"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem__bindgen_ty_2, sw_trace_info) - 0usize];
    ["Offset of field: _ocsd_generic_trace_elem__bindgen_ty_2::num_instr_range"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem__bindgen_ty_2, num_instr_range) - 0usize];
    ["Offset of field: _ocsd_generic_trace_elem__bindgen_ty_2::unsync_eot_info"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem__bindgen_ty_2, unsync_eot_info) - 0usize];
    ["Offset of field: _ocsd_generic_trace_elem__bindgen_ty_2::sync_marker"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem__bindgen_ty_2, sync_marker) - 0usize];
    ["Offset of field: _ocsd_generic_trace_elem__bindgen_ty_2::mem_trans"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem__bindgen_ty_2, mem_trans) - 0usize];
    ["Offset of field: _ocsd_generic_trace_elem__bindgen_ty_2::sw_ite"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem__bindgen_ty_2, sw_ite) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_generic_trace_elem"]
        [::std::mem::size_of::<_ocsd_generic_trace_elem>() - 96usize];
    ["Alignment of _ocsd_generic_trace_elem"]
        [::std::mem::align_of::<_ocsd_generic_trace_elem>() - 8usize];
    ["Offset of field: _ocsd_generic_trace_elem::elem_type"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem, elem_type) - 0usize];
    ["Offset of field: _ocsd_generic_trace_elem::isa"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem, isa) - 4usize];
    ["Offset of field: _ocsd_generic_trace_elem::st_addr"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem, st_addr) - 8usize];
    ["Offset of field: _ocsd_generic_trace_elem::en_addr"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem, en_addr) - 16usize];
    ["Offset of field: _ocsd_generic_trace_elem::context"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem, context) - 24usize];
    ["Offset of field: _ocsd_generic_trace_elem::timestamp"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem, timestamp) - 48usize];
    ["Offset of field: _ocsd_generic_trace_elem::cycle_count"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem, cycle_count) - 56usize];
    ["Offset of field: _ocsd_generic_trace_elem::last_i_type"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem, last_i_type) - 60usize];
    ["Offset of field: _ocsd_generic_trace_elem::last_i_subtype"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem, last_i_subtype) - 64usize];
    ["Offset of field: _ocsd_generic_trace_elem::ptr_extended_data"]
        [::std::mem::offset_of!(_ocsd_generic_trace_elem, ptr_extended_data) - 88usize];
};
pub type ocsd_generic_trace_elem = _ocsd_generic_trace_elem;
pub const _event_t_EVENT_UNKNOWN: _event_t = 0;
pub const _event_t_EVENT_TRIGGER: _event_t = 1;
pub const _event_t_EVENT_NUMBERED: _event_t = 2;
pub type _event_t = ::std::os::raw::c_uint;
pub use self::_event_t as event_t;
pub const _ocsd_pkt_va_size_VA_32BIT: _ocsd_pkt_va_size = 0;
pub const _ocsd_pkt_va_size_VA_64BIT: _ocsd_pkt_va_size = 1;
#[doc = " @name Common Packet Types\n@{"]
pub type _ocsd_pkt_va_size = ::std::os::raw::c_uint;
#[doc = " @name Common Packet Types\n@{"]
pub use self::_ocsd_pkt_va_size as ocsd_pkt_va_size;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_pkt_vaddr {
    #[doc = "< Virtual address size."]
    pub size: ocsd_pkt_va_size,
    #[doc = "< Current value"]
    pub val: ocsd_vaddr_t,
    #[doc = "< Bits updated this packet"]
    pub pkt_bits: u8,
    #[doc = "< Currently valid bits"]
    pub valid_bits: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_pkt_vaddr"][::std::mem::size_of::<_ocsd_pkt_vaddr>() - 24usize];
    ["Alignment of _ocsd_pkt_vaddr"][::std::mem::align_of::<_ocsd_pkt_vaddr>() - 8usize];
    ["Offset of field: _ocsd_pkt_vaddr::size"]
        [::std::mem::offset_of!(_ocsd_pkt_vaddr, size) - 0usize];
    ["Offset of field: _ocsd_pkt_vaddr::val"]
        [::std::mem::offset_of!(_ocsd_pkt_vaddr, val) - 8usize];
    ["Offset of field: _ocsd_pkt_vaddr::pkt_bits"]
        [::std::mem::offset_of!(_ocsd_pkt_vaddr, pkt_bits) - 16usize];
    ["Offset of field: _ocsd_pkt_vaddr::valid_bits"]
        [::std::mem::offset_of!(_ocsd_pkt_vaddr, valid_bits) - 17usize];
};
pub type ocsd_pkt_vaddr = _ocsd_pkt_vaddr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_pkt_byte_sz_val {
    pub val: u32,
    pub size_bytes: u8,
    pub valid_bytes: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_pkt_byte_sz_val"][::std::mem::size_of::<_ocsd_pkt_byte_sz_val>() - 8usize];
    ["Alignment of _ocsd_pkt_byte_sz_val"]
        [::std::mem::align_of::<_ocsd_pkt_byte_sz_val>() - 4usize];
    ["Offset of field: _ocsd_pkt_byte_sz_val::val"]
        [::std::mem::offset_of!(_ocsd_pkt_byte_sz_val, val) - 0usize];
    ["Offset of field: _ocsd_pkt_byte_sz_val::size_bytes"]
        [::std::mem::offset_of!(_ocsd_pkt_byte_sz_val, size_bytes) - 4usize];
    ["Offset of field: _ocsd_pkt_byte_sz_val::valid_bytes"]
        [::std::mem::offset_of!(_ocsd_pkt_byte_sz_val, valid_bytes) - 5usize];
};
pub type ocsd_pkt_byte_sz_val = _ocsd_pkt_byte_sz_val;
#[doc = "< set atom packet using pattern supplied"]
pub const _ocsd_pkt_atm_type_ATOM_PATTERN: _ocsd_pkt_atm_type = 0;
#[doc = "< set atom packet using repeat value (convert to pattern)"]
pub const _ocsd_pkt_atm_type_ATOM_REPEAT: _ocsd_pkt_atm_type = 1;
pub type _ocsd_pkt_atm_type = ::std::os::raw::c_uint;
pub use self::_ocsd_pkt_atm_type as ocsd_pkt_atm_type;
pub const _ocsd_atm_val_ATOM_N: _ocsd_atm_val = 0;
pub const _ocsd_atm_val_ATOM_E: _ocsd_atm_val = 1;
pub type _ocsd_atm_val = ::std::os::raw::c_uint;
pub use self::_ocsd_atm_val as ocsd_atm_val;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_pkt_atom {
    #[doc = " pattern across num bits.\nBit sequence:- ls bit = oldest atom (1st instruction executed), ms bit = newest (last instruction executed),\nBit values  :-  1'b1 = E atom, 1'b0 = N atom."]
    pub En_bits: u32,
    #[doc = "< number of atoms represented"]
    pub num: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_pkt_atom"][::std::mem::size_of::<_ocsd_pkt_atom>() - 8usize];
    ["Alignment of _ocsd_pkt_atom"][::std::mem::align_of::<_ocsd_pkt_atom>() - 4usize];
    ["Offset of field: _ocsd_pkt_atom::En_bits"]
        [::std::mem::offset_of!(_ocsd_pkt_atom, En_bits) - 0usize];
    ["Offset of field: _ocsd_pkt_atom::num"][::std::mem::offset_of!(_ocsd_pkt_atom, num) - 4usize];
};
pub type ocsd_pkt_atom = _ocsd_pkt_atom;
pub const _ocsd_iSync_reason_iSync_Periodic: _ocsd_iSync_reason = 0;
pub const _ocsd_iSync_reason_iSync_TraceEnable: _ocsd_iSync_reason = 1;
pub const _ocsd_iSync_reason_iSync_TraceRestartAfterOverflow: _ocsd_iSync_reason = 2;
pub const _ocsd_iSync_reason_iSync_DebugExit: _ocsd_iSync_reason = 3;
#[doc = " Isync Reason - common to PTM and ETMv3"]
pub type _ocsd_iSync_reason = ::std::os::raw::c_uint;
#[doc = " Isync Reason - common to PTM and ETMv3"]
pub use self::_ocsd_iSync_reason as ocsd_iSync_reason;
pub const _ocsd_armv7_exception_Excp_Reserved: _ocsd_armv7_exception = 0;
pub const _ocsd_armv7_exception_Excp_NoException: _ocsd_armv7_exception = 1;
pub const _ocsd_armv7_exception_Excp_Reset: _ocsd_armv7_exception = 2;
pub const _ocsd_armv7_exception_Excp_IRQ: _ocsd_armv7_exception = 3;
pub const _ocsd_armv7_exception_Excp_FIQ: _ocsd_armv7_exception = 4;
pub const _ocsd_armv7_exception_Excp_AsyncDAbort: _ocsd_armv7_exception = 5;
pub const _ocsd_armv7_exception_Excp_DebugHalt: _ocsd_armv7_exception = 6;
pub const _ocsd_armv7_exception_Excp_Jazelle: _ocsd_armv7_exception = 7;
pub const _ocsd_armv7_exception_Excp_SVC: _ocsd_armv7_exception = 8;
pub const _ocsd_armv7_exception_Excp_SMC: _ocsd_armv7_exception = 9;
pub const _ocsd_armv7_exception_Excp_Hyp: _ocsd_armv7_exception = 10;
pub const _ocsd_armv7_exception_Excp_Undef: _ocsd_armv7_exception = 11;
pub const _ocsd_armv7_exception_Excp_PrefAbort: _ocsd_armv7_exception = 12;
pub const _ocsd_armv7_exception_Excp_Generic: _ocsd_armv7_exception = 13;
pub const _ocsd_armv7_exception_Excp_SyncDataAbort: _ocsd_armv7_exception = 14;
pub const _ocsd_armv7_exception_Excp_CMUsageFault: _ocsd_armv7_exception = 15;
pub const _ocsd_armv7_exception_Excp_CMNMI: _ocsd_armv7_exception = 16;
pub const _ocsd_armv7_exception_Excp_CMDebugMonitor: _ocsd_armv7_exception = 17;
pub const _ocsd_armv7_exception_Excp_CMMemManage: _ocsd_armv7_exception = 18;
pub const _ocsd_armv7_exception_Excp_CMPendSV: _ocsd_armv7_exception = 19;
pub const _ocsd_armv7_exception_Excp_CMSysTick: _ocsd_armv7_exception = 20;
pub const _ocsd_armv7_exception_Excp_CMBusFault: _ocsd_armv7_exception = 21;
pub const _ocsd_armv7_exception_Excp_CMHardFault: _ocsd_armv7_exception = 22;
pub const _ocsd_armv7_exception_Excp_CMIRQn: _ocsd_armv7_exception = 23;
pub const _ocsd_armv7_exception_Excp_ThumbEECheckFail: _ocsd_armv7_exception = 24;
pub type _ocsd_armv7_exception = ::std::os::raw::c_uint;
pub use self::_ocsd_armv7_exception as ocsd_armv7_exception;
#[doc = "!< no error in packet - supplimentary data."]
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_NOERROR: _ocsd_etmv3_pkt_type = 0;
#[doc = "!< no sync found yet"]
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_NOTSYNC: _ocsd_etmv3_pkt_type = 1;
#[doc = "!< flushing incomplete/empty packet at end of trace."]
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_INCOMPLETE_EOT: _ocsd_etmv3_pkt_type = 2;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_BRANCH_ADDRESS: _ocsd_etmv3_pkt_type = 3;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_A_SYNC: _ocsd_etmv3_pkt_type = 4;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_CYCLE_COUNT: _ocsd_etmv3_pkt_type = 5;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_I_SYNC: _ocsd_etmv3_pkt_type = 6;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_I_SYNC_CYCLE: _ocsd_etmv3_pkt_type = 7;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_TRIGGER: _ocsd_etmv3_pkt_type = 8;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_P_HDR: _ocsd_etmv3_pkt_type = 9;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_STORE_FAIL: _ocsd_etmv3_pkt_type = 10;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_OOO_DATA: _ocsd_etmv3_pkt_type = 11;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_OOO_ADDR_PLC: _ocsd_etmv3_pkt_type = 12;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_NORM_DATA: _ocsd_etmv3_pkt_type = 13;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_DATA_SUPPRESSED: _ocsd_etmv3_pkt_type = 14;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_VAL_NOT_TRACED: _ocsd_etmv3_pkt_type = 15;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_IGNORE: _ocsd_etmv3_pkt_type = 16;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_CONTEXT_ID: _ocsd_etmv3_pkt_type = 17;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_VMID: _ocsd_etmv3_pkt_type = 18;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_EXCEPTION_ENTRY: _ocsd_etmv3_pkt_type = 19;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_EXCEPTION_EXIT: _ocsd_etmv3_pkt_type = 20;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_TIMESTAMP: _ocsd_etmv3_pkt_type = 21;
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_BRANCH_OR_BYPASS_EOT: _ocsd_etmv3_pkt_type = 22;
#[doc = "!< invalid sequence for packet type"]
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_BAD_SEQUENCE: _ocsd_etmv3_pkt_type = 23;
#[doc = "!< invalid packet type for this trace mode."]
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_BAD_TRACEMODE: _ocsd_etmv3_pkt_type = 24;
#[doc = "!< packet type reserved."]
pub const _ocsd_etmv3_pkt_type_ETM3_PKT_RESERVED: _ocsd_etmv3_pkt_type = 25;
#[doc = " @name ETMv3 Packet Types\n@{"]
pub type _ocsd_etmv3_pkt_type = ::std::os::raw::c_uint;
#[doc = " @name ETMv3 Packet Types\n@{"]
pub use self::_ocsd_etmv3_pkt_type as ocsd_etmv3_pkt_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv3_excep {
    #[doc = "<  exception type."]
    pub type_: ocsd_armv7_exception,
    #[doc = "< exception as number"]
    pub number: u16,
    pub bits: _ocsd_etmv3_excep__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv3_excep__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv3_excep__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_etmv3_excep__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_etmv3_excep__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_etmv3_excep__bindgen_ty_1>() - 4usize];
};
impl _ocsd_etmv3_excep__bindgen_ty_1 {
    #[inline]
    pub fn present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn present_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_present_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cancel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cancel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cancel_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cancel_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cm_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cm_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cm_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cm_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cm_resume(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cm_resume(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cm_resume_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cm_resume_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cm_irq_n(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_cm_irq_n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cm_irq_n_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cm_irq_n_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        present: u32,
        cancel: u32,
        cm_type: u32,
        cm_resume: u32,
        cm_irq_n: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let present: u32 = unsafe { ::std::mem::transmute(present) };
            present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cancel: u32 = unsafe { ::std::mem::transmute(cancel) };
            cancel as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cm_type: u32 = unsafe { ::std::mem::transmute(cm_type) };
            cm_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let cm_resume: u32 = unsafe { ::std::mem::transmute(cm_resume) };
            cm_resume as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let cm_irq_n: u32 = unsafe { ::std::mem::transmute(cm_irq_n) };
            cm_irq_n as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv3_excep"][::std::mem::size_of::<_ocsd_etmv3_excep>() - 12usize];
    ["Alignment of _ocsd_etmv3_excep"][::std::mem::align_of::<_ocsd_etmv3_excep>() - 4usize];
    ["Offset of field: _ocsd_etmv3_excep::type_"]
        [::std::mem::offset_of!(_ocsd_etmv3_excep, type_) - 0usize];
    ["Offset of field: _ocsd_etmv3_excep::number"]
        [::std::mem::offset_of!(_ocsd_etmv3_excep, number) - 4usize];
    ["Offset of field: _ocsd_etmv3_excep::bits"]
        [::std::mem::offset_of!(_ocsd_etmv3_excep, bits) - 8usize];
};
pub type ocsd_etmv3_excep = _ocsd_etmv3_excep;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _etmv3_context_t {
    pub __bindgen_anon_1: _etmv3_context_t__bindgen_ty_1,
    #[doc = "< Context ID"]
    pub ctxtID: u32,
    #[doc = "< VMID"]
    pub VMID: u8,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _etmv3_context_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv3_context_t__bindgen_ty_1"]
        [::std::mem::size_of::<_etmv3_context_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _etmv3_context_t__bindgen_ty_1"]
        [::std::mem::align_of::<_etmv3_context_t__bindgen_ty_1>() - 4usize];
};
impl _etmv3_context_t__bindgen_ty_1 {
    #[inline]
    pub fn curr_alt_isa(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_curr_alt_isa(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn curr_alt_isa_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_curr_alt_isa_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn curr_NS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_curr_NS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn curr_NS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_curr_NS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn curr_Hyp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_curr_Hyp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn curr_Hyp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_curr_Hyp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn updated(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn updated_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_updated_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn updated_c(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn updated_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_updated_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn updated_v(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated_v(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn updated_v_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_updated_v_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        curr_alt_isa: u32,
        curr_NS: u32,
        curr_Hyp: u32,
        updated: u32,
        updated_c: u32,
        updated_v: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let curr_alt_isa: u32 = unsafe { ::std::mem::transmute(curr_alt_isa) };
            curr_alt_isa as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let curr_NS: u32 = unsafe { ::std::mem::transmute(curr_NS) };
            curr_NS as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let curr_Hyp: u32 = unsafe { ::std::mem::transmute(curr_Hyp) };
            curr_Hyp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let updated: u32 = unsafe { ::std::mem::transmute(updated) };
            updated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let updated_c: u32 = unsafe { ::std::mem::transmute(updated_c) };
            updated_c as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let updated_v: u32 = unsafe { ::std::mem::transmute(updated_v) };
            updated_v as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv3_context_t"][::std::mem::size_of::<_etmv3_context_t>() - 12usize];
    ["Alignment of _etmv3_context_t"][::std::mem::align_of::<_etmv3_context_t>() - 4usize];
    ["Offset of field: _etmv3_context_t::ctxtID"]
        [::std::mem::offset_of!(_etmv3_context_t, ctxtID) - 4usize];
    ["Offset of field: _etmv3_context_t::VMID"]
        [::std::mem::offset_of!(_etmv3_context_t, VMID) - 8usize];
};
pub type etmv3_context_t = _etmv3_context_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _etmv3_data_t {
    #[doc = "< Data value"]
    pub value: u32,
    #[doc = "< current data address"]
    pub addr: ocsd_pkt_vaddr,
    pub __bindgen_anon_1: _etmv3_data_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _etmv3_data_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv3_data_t__bindgen_ty_1"]
        [::std::mem::size_of::<_etmv3_data_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _etmv3_data_t__bindgen_ty_1"]
        [::std::mem::align_of::<_etmv3_data_t__bindgen_ty_1>() - 4usize];
};
impl _etmv3_data_t__bindgen_ty_1 {
    #[inline]
    pub fn ooo_tag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ooo_tag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ooo_tag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ooo_tag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn be(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_be(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn be_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_be_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn update_be(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_be(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn update_be_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_update_be_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn update_addr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn update_addr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_update_addr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn update_dval(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_dval(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn update_dval_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_update_dval_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ooo_tag: u32,
        be: u32,
        update_be: u32,
        update_addr: u32,
        update_dval: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let ooo_tag: u32 = unsafe { ::std::mem::transmute(ooo_tag) };
            ooo_tag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let be: u32 = unsafe { ::std::mem::transmute(be) };
            be as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let update_be: u32 = unsafe { ::std::mem::transmute(update_be) };
            update_be as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let update_addr: u32 = unsafe { ::std::mem::transmute(update_addr) };
            update_addr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let update_dval: u32 = unsafe { ::std::mem::transmute(update_dval) };
            update_dval as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv3_data_t"][::std::mem::size_of::<_etmv3_data_t>() - 40usize];
    ["Alignment of _etmv3_data_t"][::std::mem::align_of::<_etmv3_data_t>() - 8usize];
    ["Offset of field: _etmv3_data_t::value"]
        [::std::mem::offset_of!(_etmv3_data_t, value) - 0usize];
    ["Offset of field: _etmv3_data_t::addr"][::std::mem::offset_of!(_etmv3_data_t, addr) - 8usize];
};
pub type etmv3_data_t = _etmv3_data_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _etmv3_isync_t {
    pub reason: ocsd_iSync_reason,
    pub __bindgen_anon_1: _etmv3_isync_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _etmv3_isync_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv3_isync_t__bindgen_ty_1"]
        [::std::mem::size_of::<_etmv3_isync_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _etmv3_isync_t__bindgen_ty_1"]
        [::std::mem::align_of::<_etmv3_isync_t__bindgen_ty_1>() - 4usize];
};
impl _etmv3_isync_t__bindgen_ty_1 {
    #[inline]
    pub fn has_cycle_count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_cycle_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_cycle_count_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_cycle_count_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_LSipAddress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_LSipAddress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_LSipAddress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_LSipAddress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_address(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_address(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_address_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_address_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_cycle_count: u32,
        has_LSipAddress: u32,
        no_address: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_cycle_count: u32 = unsafe { ::std::mem::transmute(has_cycle_count) };
            has_cycle_count as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_LSipAddress: u32 = unsafe { ::std::mem::transmute(has_LSipAddress) };
            has_LSipAddress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_address: u32 = unsafe { ::std::mem::transmute(no_address) };
            no_address as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv3_isync_t"][::std::mem::size_of::<_etmv3_isync_t>() - 8usize];
    ["Alignment of _etmv3_isync_t"][::std::mem::align_of::<_etmv3_isync_t>() - 4usize];
    ["Offset of field: _etmv3_isync_t::reason"]
        [::std::mem::offset_of!(_etmv3_isync_t, reason) - 0usize];
};
pub type etmv3_isync_t = _etmv3_isync_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv3_pkt {
    #[doc = "< Primary packet type."]
    pub type_: ocsd_etmv3_pkt_type,
    #[doc = "< current ISA"]
    pub curr_isa: ocsd_isa,
    #[doc = "< ISA in previous packet"]
    pub prev_isa: ocsd_isa,
    #[doc = "< current context"]
    pub context: etmv3_context_t,
    #[doc = "< current Addr"]
    pub addr: ocsd_pkt_vaddr,
    pub isync_info: etmv3_isync_t,
    pub exception: ocsd_etmv3_excep,
    #[doc = "< atom elements - non zerom number indicates valid atom count"]
    pub atom: ocsd_pkt_atom,
    #[doc = "< if atom elements, associated phdr format"]
    pub p_hdr_fmt: u8,
    #[doc = "< cycle count associated with this packet (ETMv3 has counts in atom packets and as individual packets"]
    pub cycle_count: u32,
    #[doc = "< current timestamp value"]
    pub timestamp: u64,
    #[doc = "< bits of ts updated this packet (if TS packet)"]
    pub ts_update_bits: u8,
    #[doc = "< data transfer values"]
    pub data: etmv3_data_t,
    #[doc = "< Basic packet type if primary type indicates error or incomplete. (header type)"]
    pub err_type: ocsd_etmv3_pkt_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv3_pkt"][::std::mem::size_of::<_ocsd_etmv3_pkt>() - 152usize];
    ["Alignment of _ocsd_etmv3_pkt"][::std::mem::align_of::<_ocsd_etmv3_pkt>() - 8usize];
    ["Offset of field: _ocsd_etmv3_pkt::type_"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, type_) - 0usize];
    ["Offset of field: _ocsd_etmv3_pkt::curr_isa"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, curr_isa) - 4usize];
    ["Offset of field: _ocsd_etmv3_pkt::prev_isa"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, prev_isa) - 8usize];
    ["Offset of field: _ocsd_etmv3_pkt::context"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, context) - 12usize];
    ["Offset of field: _ocsd_etmv3_pkt::addr"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, addr) - 24usize];
    ["Offset of field: _ocsd_etmv3_pkt::isync_info"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, isync_info) - 48usize];
    ["Offset of field: _ocsd_etmv3_pkt::exception"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, exception) - 56usize];
    ["Offset of field: _ocsd_etmv3_pkt::atom"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, atom) - 68usize];
    ["Offset of field: _ocsd_etmv3_pkt::p_hdr_fmt"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, p_hdr_fmt) - 76usize];
    ["Offset of field: _ocsd_etmv3_pkt::cycle_count"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, cycle_count) - 80usize];
    ["Offset of field: _ocsd_etmv3_pkt::timestamp"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, timestamp) - 88usize];
    ["Offset of field: _ocsd_etmv3_pkt::ts_update_bits"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, ts_update_bits) - 96usize];
    ["Offset of field: _ocsd_etmv3_pkt::data"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, data) - 104usize];
    ["Offset of field: _ocsd_etmv3_pkt::err_type"]
        [::std::mem::offset_of!(_ocsd_etmv3_pkt, err_type) - 144usize];
};
pub type ocsd_etmv3_pkt = _ocsd_etmv3_pkt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv3_cfg {
    #[doc = "< ID register"]
    pub reg_idr: u32,
    #[doc = "< Control Register"]
    pub reg_ctrl: u32,
    #[doc = "< CCER register"]
    pub reg_ccer: u32,
    #[doc = "< Trace Stream ID register"]
    pub reg_trc_id: u32,
    #[doc = "< Architecture version"]
    pub arch_ver: ocsd_arch_version_t,
    #[doc = "< Core Profile"]
    pub core_prof: ocsd_core_profile_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv3_cfg"][::std::mem::size_of::<_ocsd_etmv3_cfg>() - 24usize];
    ["Alignment of _ocsd_etmv3_cfg"][::std::mem::align_of::<_ocsd_etmv3_cfg>() - 4usize];
    ["Offset of field: _ocsd_etmv3_cfg::reg_idr"]
        [::std::mem::offset_of!(_ocsd_etmv3_cfg, reg_idr) - 0usize];
    ["Offset of field: _ocsd_etmv3_cfg::reg_ctrl"]
        [::std::mem::offset_of!(_ocsd_etmv3_cfg, reg_ctrl) - 4usize];
    ["Offset of field: _ocsd_etmv3_cfg::reg_ccer"]
        [::std::mem::offset_of!(_ocsd_etmv3_cfg, reg_ccer) - 8usize];
    ["Offset of field: _ocsd_etmv3_cfg::reg_trc_id"]
        [::std::mem::offset_of!(_ocsd_etmv3_cfg, reg_trc_id) - 12usize];
    ["Offset of field: _ocsd_etmv3_cfg::arch_ver"]
        [::std::mem::offset_of!(_ocsd_etmv3_cfg, arch_ver) - 16usize];
    ["Offset of field: _ocsd_etmv3_cfg::core_prof"]
        [::std::mem::offset_of!(_ocsd_etmv3_cfg, core_prof) - 20usize];
};
pub type ocsd_etmv3_cfg = _ocsd_etmv3_cfg;
#[doc = "< no sync found yet."]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_NOTSYNC: _ocsd_etmv4_i_pkt_type = 512;
#[doc = "< flushing incomplete/empty packet at end of trace."]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_INCOMPLETE_EOT: _ocsd_etmv4_i_pkt_type = 513;
#[doc = "< error type not set for packet."]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_NO_ERR_TYPE: _ocsd_etmv4_i_pkt_type = 514;
#[doc = "< invalid sequence for packet type."]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_BAD_SEQUENCE: _ocsd_etmv4_i_pkt_type = 768;
#[doc = "< invalid packet type for this trace mode."]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_BAD_TRACEMODE: _ocsd_etmv4_i_pkt_type = 769;
#[doc = "< packet type reserved."]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_RESERVED: _ocsd_etmv4_i_pkt_type = 770;
#[doc = "< packet type reserved for current configuration"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_RESERVED_CFG: _ocsd_etmv4_i_pkt_type = 771;
#[doc = "< b00000000"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_EXTENSION: _ocsd_etmv4_i_pkt_type = 0;
#[doc = "< b00000001"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_TRACE_INFO: _ocsd_etmv4_i_pkt_type = 1;
#[doc = "< b0000001x"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_TIMESTAMP: _ocsd_etmv4_i_pkt_type = 2;
#[doc = "< b00000100"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_TRACE_ON: _ocsd_etmv4_i_pkt_type = 4;
#[doc = "< b00000101 (V8M only)"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_FUNC_RET: _ocsd_etmv4_i_pkt_type = 5;
#[doc = "< b00000110"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_EXCEPT: _ocsd_etmv4_i_pkt_type = 6;
#[doc = "< b00000111 (ETE invalid)"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_EXCEPT_RTN: _ocsd_etmv4_i_pkt_type = 7;
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_ITE: _ocsd_etmv4_i_pkt_type = 9;
#[doc = "  b00001001 (ETE only)"]
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_TRANS_ST: _ocsd_etmv4_i_pkt_type = 10;
#[doc = "  b00001010 (ETE only)"]
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_TRANS_COMMIT: _ocsd_etmv4_i_pkt_type = 11;
#[doc = "< b0000110x"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_CCNT_F2: _ocsd_etmv4_i_pkt_type = 12;
#[doc = "< b0000111x"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_CCNT_F1: _ocsd_etmv4_i_pkt_type = 14;
#[doc = "< b0001xxxx"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_CCNT_F3: _ocsd_etmv4_i_pkt_type = 16;
#[doc = "< b00100xxx"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_NUM_DS_MKR: _ocsd_etmv4_i_pkt_type = 32;
#[doc = "< b00101000 to b00101100 0x2C"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_UNNUM_DS_MKR: _ocsd_etmv4_i_pkt_type = 40;
#[doc = "< b00101101"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_COMMIT: _ocsd_etmv4_i_pkt_type = 45;
#[doc = "< b00101110"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_CANCEL_F1: _ocsd_etmv4_i_pkt_type = 46;
#[doc = "< b00101111"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_CANCEL_F1_MISPRED: _ocsd_etmv4_i_pkt_type = 47;
#[doc = "< b001100xx"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_MISPREDICT: _ocsd_etmv4_i_pkt_type = 48;
#[doc = "< b001101xx"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_CANCEL_F2: _ocsd_etmv4_i_pkt_type = 52;
#[doc = "< b00111xxx"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_CANCEL_F3: _ocsd_etmv4_i_pkt_type = 56;
#[doc = "< b01000000 - b01000010"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_COND_I_F2: _ocsd_etmv4_i_pkt_type = 64;
#[doc = "< b01000011"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_COND_FLUSH: _ocsd_etmv4_i_pkt_type = 67;
#[doc = "< b0100010x, b01000110"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_COND_RES_F4: _ocsd_etmv4_i_pkt_type = 68;
#[doc = "< b0100100x, b01001010, b0100110x, b01001110"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_COND_RES_F2: _ocsd_etmv4_i_pkt_type = 72;
#[doc = "< b0101xxxx"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_COND_RES_F3: _ocsd_etmv4_i_pkt_type = 80;
#[doc = "< b011010xx, b0110111x  0x68-0x6B, 0x6e-0x6F"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_COND_RES_F1: _ocsd_etmv4_i_pkt_type = 104;
#[doc = "< b01101100"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_COND_I_F1: _ocsd_etmv4_i_pkt_type = 108;
#[doc = "< b01101101"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_COND_I_F3: _ocsd_etmv4_i_pkt_type = 109;
#[doc = "< b01110000"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_IGNORE: _ocsd_etmv4_i_pkt_type = 112;
#[doc = "< b01110001 to 0x01111111 0x7F"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_EVENT: _ocsd_etmv4_i_pkt_type = 113;
#[doc = "< b1000000x"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_CTXT: _ocsd_etmv4_i_pkt_type = 128;
#[doc = "< b10000010"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_CTXT_L_32IS0: _ocsd_etmv4_i_pkt_type = 130;
#[doc = "< b10000011"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_CTXT_L_32IS1: _ocsd_etmv4_i_pkt_type = 131;
#[doc = "< b10000101"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_CTXT_L_64IS0: _ocsd_etmv4_i_pkt_type = 133;
#[doc = "< b10000110"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_CTXT_L_64IS1: _ocsd_etmv4_i_pkt_type = 134;
#[doc = "< b10001000"]
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_TS_MARKER: _ocsd_etmv4_i_pkt_type = 136;
#[doc = "< b10010000 to b10010010 0x92"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_MATCH: _ocsd_etmv4_i_pkt_type = 144;
#[doc = "< b10010101"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_S_IS0: _ocsd_etmv4_i_pkt_type = 149;
#[doc = "< b10010110"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_S_IS1: _ocsd_etmv4_i_pkt_type = 150;
#[doc = "< b10011010"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_L_32IS0: _ocsd_etmv4_i_pkt_type = 154;
#[doc = "< b10011011"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_L_32IS1: _ocsd_etmv4_i_pkt_type = 155;
#[doc = "< b10011101"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_L_64IS0: _ocsd_etmv4_i_pkt_type = 157;
#[doc = "< b10011110"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ADDR_L_64IS1: _ocsd_etmv4_i_pkt_type = 158;
#[doc = "< b1010xxxx"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_Q: _ocsd_etmv4_i_pkt_type = 160;
#[doc = "< b101100xx"]
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_SRC_ADDR_MATCH: _ocsd_etmv4_i_pkt_type = 176;
#[doc = "< b10110100"]
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_SRC_ADDR_S_IS0: _ocsd_etmv4_i_pkt_type = 180;
#[doc = "< b10110101"]
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_SRC_ADDR_S_IS1: _ocsd_etmv4_i_pkt_type = 181;
#[doc = "< b10110110"]
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_SRC_ADDR_L_32IS0: _ocsd_etmv4_i_pkt_type = 182;
#[doc = "< b10110111"]
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_SRC_ADDR_L_32IS1: _ocsd_etmv4_i_pkt_type = 183;
#[doc = "< b10111000"]
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_SRC_ADDR_L_64IS0: _ocsd_etmv4_i_pkt_type = 184;
#[doc = "< b10111001"]
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_SRC_ADDR_L_64IS1: _ocsd_etmv4_i_pkt_type = 185;
#[doc = "< b11000000 - b11010100 0xC0 - 0xD4, b11100000 - b11110100 0xE0 - 0xF4"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ATOM_F6: _ocsd_etmv4_i_pkt_type = 192;
#[doc = "< b11010101 - b11010111 0xD5 - 0xD7, b11110101 0xF5"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ATOM_F5: _ocsd_etmv4_i_pkt_type = 213;
#[doc = "< b110110xx to 0xDB"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ATOM_F2: _ocsd_etmv4_i_pkt_type = 216;
#[doc = "< b110111xx to 0xDF"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ATOM_F4: _ocsd_etmv4_i_pkt_type = 220;
#[doc = "< b1111011x to 0xF7"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ATOM_F1: _ocsd_etmv4_i_pkt_type = 246;
#[doc = "< b11111xxx to 0xFF"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ATOM_F3: _ocsd_etmv4_i_pkt_type = 248;
#[doc = "!< b00000000"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_ASYNC: _ocsd_etmv4_i_pkt_type = 256;
#[doc = "!< b00000011"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_DISCARD: _ocsd_etmv4_i_pkt_type = 259;
#[doc = "!< b00000101"]
pub const _ocsd_etmv4_i_pkt_type_ETM4_PKT_I_OVERFLOW: _ocsd_etmv4_i_pkt_type = 261;
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_PE_RESET: _ocsd_etmv4_i_pkt_type = 1024;
pub const _ocsd_etmv4_i_pkt_type_ETE_PKT_I_TRANS_FAIL: _ocsd_etmv4_i_pkt_type = 1025;
#[doc = " I stream packets."]
pub type _ocsd_etmv4_i_pkt_type = ::std::os::raw::c_uint;
#[doc = " I stream packets."]
pub use self::_ocsd_etmv4_i_pkt_type as ocsd_etmv4_i_pkt_type;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _etmv4_trace_info_t {
    #[doc = "!< trace info full value."]
    pub val: u32,
    #[doc = "!< bitfields for trace info value."]
    pub bits: _etmv4_trace_info_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _etmv4_trace_info_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv4_trace_info_t__bindgen_ty_1"]
        [::std::mem::size_of::<_etmv4_trace_info_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _etmv4_trace_info_t__bindgen_ty_1"]
        [::std::mem::align_of::<_etmv4_trace_info_t__bindgen_ty_1>() - 4usize];
};
impl _etmv4_trace_info_t__bindgen_ty_1 {
    #[inline]
    pub fn cc_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cc_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cc_enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cc_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cond_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cond_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cond_enabled_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cond_enabled_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn p0_load(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_p0_load(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn p0_load_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_p0_load_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn p0_store(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_p0_store(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn p0_store_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_p0_store_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_trans_state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_trans_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_trans_state_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_trans_state_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cc_enabled: u32,
        cond_enabled: u32,
        p0_load: u32,
        p0_store: u32,
        in_trans_state: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cc_enabled: u32 = unsafe { ::std::mem::transmute(cc_enabled) };
            cc_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let cond_enabled: u32 = unsafe { ::std::mem::transmute(cond_enabled) };
            cond_enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let p0_load: u32 = unsafe { ::std::mem::transmute(p0_load) };
            p0_load as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let p0_store: u32 = unsafe { ::std::mem::transmute(p0_store) };
            p0_store as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let in_trans_state: u32 = unsafe { ::std::mem::transmute(in_trans_state) };
            in_trans_state as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv4_trace_info_t"][::std::mem::size_of::<_etmv4_trace_info_t>() - 4usize];
    ["Alignment of _etmv4_trace_info_t"][::std::mem::align_of::<_etmv4_trace_info_t>() - 4usize];
    ["Offset of field: _etmv4_trace_info_t::val"]
        [::std::mem::offset_of!(_etmv4_trace_info_t, val) - 0usize];
    ["Offset of field: _etmv4_trace_info_t::bits"]
        [::std::mem::offset_of!(_etmv4_trace_info_t, bits) - 0usize];
};
pub type etmv4_trace_info_t = _etmv4_trace_info_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _etmv4_context_t {
    pub __bindgen_anon_1: _etmv4_context_t__bindgen_ty_1,
    #[doc = "!< Current ctxtID"]
    pub ctxtID: u32,
    #[doc = "!< current VMID"]
    pub VMID: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _etmv4_context_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv4_context_t__bindgen_ty_1"]
        [::std::mem::size_of::<_etmv4_context_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _etmv4_context_t__bindgen_ty_1"]
        [::std::mem::align_of::<_etmv4_context_t__bindgen_ty_1>() - 4usize];
};
impl _etmv4_context_t__bindgen_ty_1 {
    #[inline]
    pub fn EL(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_EL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EL_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EL_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SF(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SF_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SF_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn updated(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn updated_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_updated_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn updated_c(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn updated_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_updated_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn updated_v(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated_v(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn updated_v_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_updated_v_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NSE(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NSE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NSE_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NSE_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EL: u32,
        SF: u32,
        NS: u32,
        updated: u32,
        updated_c: u32,
        updated_v: u32,
        NSE: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let EL: u32 = unsafe { ::std::mem::transmute(EL) };
            EL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SF: u32 = unsafe { ::std::mem::transmute(SF) };
            SF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NS: u32 = unsafe { ::std::mem::transmute(NS) };
            NS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let updated: u32 = unsafe { ::std::mem::transmute(updated) };
            updated as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let updated_c: u32 = unsafe { ::std::mem::transmute(updated_c) };
            updated_c as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let updated_v: u32 = unsafe { ::std::mem::transmute(updated_v) };
            updated_v as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let NSE: u32 = unsafe { ::std::mem::transmute(NSE) };
            NSE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv4_context_t"][::std::mem::size_of::<_etmv4_context_t>() - 12usize];
    ["Alignment of _etmv4_context_t"][::std::mem::align_of::<_etmv4_context_t>() - 4usize];
    ["Offset of field: _etmv4_context_t::ctxtID"]
        [::std::mem::offset_of!(_etmv4_context_t, ctxtID) - 4usize];
    ["Offset of field: _etmv4_context_t::VMID"]
        [::std::mem::offset_of!(_etmv4_context_t, VMID) - 8usize];
};
pub type etmv4_context_t = _etmv4_context_t;
#[doc = " a broadcast address value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _etmv4_addr_val_t {
    #[doc = "!< Address value."]
    pub val: ocsd_vaddr_t,
    #[doc = "!< instruction set."]
    pub isa: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _etmv4_addr_val_t"][::std::mem::size_of::<_etmv4_addr_val_t>() - 16usize];
    ["Alignment of _etmv4_addr_val_t"][::std::mem::align_of::<_etmv4_addr_val_t>() - 8usize];
    ["Offset of field: _etmv4_addr_val_t::val"]
        [::std::mem::offset_of!(_etmv4_addr_val_t, val) - 0usize];
    ["Offset of field: _etmv4_addr_val_t::isa"]
        [::std::mem::offset_of!(_etmv4_addr_val_t, isa) - 8usize];
};
#[doc = " a broadcast address value."]
pub type etmv4_addr_val_t = _etmv4_addr_val_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt {
    #[doc = "< Trace packet type derived from header byte"]
    pub type_: ocsd_etmv4_i_pkt_type,
    #[doc = "!< most recently broadcast address packet"]
    pub v_addr: ocsd_pkt_vaddr,
    #[doc = "!< ISA for the address packet. (0 = IS0 / 1 = IS1)"]
    pub v_addr_ISA: u8,
    #[doc = "!< current context for PE"]
    pub context: etmv4_context_t,
    pub ts: _ocsd_etmv4_i_pkt__bindgen_ty_1,
    #[doc = "!< cycle count threshold - from trace info."]
    pub cc_threshold: u32,
    #[doc = "!< atom elements - number of atoms indicates validity of packet"]
    pub atom: ocsd_pkt_atom,
    #[doc = "!< cycle count"]
    pub cycle_count: u32,
    #[doc = "!< current speculation depth"]
    pub curr_spec_depth: u32,
    #[doc = "!< current P0 key value for data packet synchronisation"]
    pub p0_key: u32,
    pub commit_elements: u32,
    pub cancel_elements: u32,
    #[doc = "!< trace info structure - programmed configuration of trace capture."]
    pub trace_info: etmv4_trace_info_t,
    pub exception_info: _ocsd_etmv4_i_pkt__bindgen_ty_2,
    #[doc = "!< address match index in this packet."]
    pub addr_exact_match_idx: u8,
    #[doc = "!<  Data Sync Marker number, or unnumbered atom count - packet type determines."]
    pub dsm_val: u8,
    #[doc = "!< Event value on event packet."]
    pub event_val: u8,
    pub cond_instr: _ocsd_etmv4_i_pkt__bindgen_ty_3,
    pub cond_result: _ocsd_etmv4_i_pkt__bindgen_ty_4,
    pub Q_pkt: _ocsd_etmv4_i_pkt__bindgen_ty_5,
    pub ite_pkt: _ocsd_etmv4_i_pkt__bindgen_ty_6,
    pub pkt_valid: _ocsd_etmv4_i_pkt__bindgen_ty_7,
    pub err_type: ocsd_etmv4_i_pkt_type,
    pub err_hdr_val: u8,
    pub protocol_version: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt__bindgen_ty_1 {
    #[doc = "!< current timestamp value"]
    pub timestamp: u64,
    #[doc = "!< bits updated in this timestamp packet."]
    pub bits_changed: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_1>() - 16usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_1>() - 8usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_1::timestamp"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_1, timestamp) - 0usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_1::bits_changed"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_1, bits_changed) - 8usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_2"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_2>() - 4usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_2"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_2>() - 4usize];
};
impl _ocsd_etmv4_i_pkt__bindgen_ty_2 {
    #[inline]
    pub fn exceptionType(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_exceptionType(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn exceptionType_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_exceptionType_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addr_interp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_addr_interp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addr_interp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_addr_interp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn m_fault_pending(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_m_fault_pending(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn m_fault_pending_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_m_fault_pending_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn m_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_m_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn m_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_m_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        exceptionType: u32,
        addr_interp: u32,
        m_fault_pending: u32,
        m_type: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let exceptionType: u32 = unsafe { ::std::mem::transmute(exceptionType) };
            exceptionType as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let addr_interp: u32 = unsafe { ::std::mem::transmute(addr_interp) };
            addr_interp as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let m_fault_pending: u32 = unsafe { ::std::mem::transmute(m_fault_pending) };
            m_fault_pending as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let m_type: u32 = unsafe { ::std::mem::transmute(m_type) };
            m_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt__bindgen_ty_3 {
    pub cond_c_key: u32,
    pub num_c_elem: u8,
    pub __bindgen_anon_1: _ocsd_etmv4_i_pkt__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_3__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_3__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_3__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_3__bindgen_ty_1>() - 4usize];
};
impl _ocsd_etmv4_i_pkt__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn cond_key_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cond_key_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cond_key_set_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cond_key_set_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn f3_final_elem(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_f3_final_elem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn f3_final_elem_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_f3_final_elem_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn f2_cond_incr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_f2_cond_incr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn f2_cond_incr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_f2_cond_incr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cond_key_set: u32,
        f3_final_elem: u32,
        f2_cond_incr: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cond_key_set: u32 = unsafe { ::std::mem::transmute(cond_key_set) };
            cond_key_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let f3_final_elem: u32 = unsafe { ::std::mem::transmute(f3_final_elem) };
            f3_final_elem as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let f2_cond_incr: u32 = unsafe { ::std::mem::transmute(f2_cond_incr) };
            f2_cond_incr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_3"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_3>() - 12usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_3"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_3>() - 4usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_3::cond_c_key"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_3, cond_c_key) - 0usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_3::num_c_elem"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_3, num_c_elem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt__bindgen_ty_4 {
    pub cond_r_key_0: u32,
    pub cond_r_key_1: u32,
    pub __bindgen_anon_1: _ocsd_etmv4_i_pkt__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_4__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_4__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_4__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_4__bindgen_ty_1>() - 4usize];
};
impl _ocsd_etmv4_i_pkt__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn res_0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_res_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res_0_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res_0_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_res_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res_1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res_1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ci_0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ci_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ci_0_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ci_0_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ci_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ci_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ci_1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ci_1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn key_res_0_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_key_res_0_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn key_res_0_set_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_key_res_0_set_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn key_res_1_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_key_res_1_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn key_res_1_set_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_key_res_1_set_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn f2_key_incr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_f2_key_incr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn f2_key_incr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_f2_key_incr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn f2f4_token(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_f2f4_token(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn f2f4_token_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_f2f4_token_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn f3_tokens(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_f3_tokens(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn f3_tokens_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_f3_tokens_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res_0: u32,
        res_1: u32,
        ci_0: u32,
        ci_1: u32,
        key_res_0_set: u32,
        key_res_1_set: u32,
        f2_key_incr: u32,
        f2f4_token: u32,
        f3_tokens: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res_0: u32 = unsafe { ::std::mem::transmute(res_0) };
            res_0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let res_1: u32 = unsafe { ::std::mem::transmute(res_1) };
            res_1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ci_0: u32 = unsafe { ::std::mem::transmute(ci_0) };
            ci_0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ci_1: u32 = unsafe { ::std::mem::transmute(ci_1) };
            ci_1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let key_res_0_set: u32 = unsafe { ::std::mem::transmute(key_res_0_set) };
            key_res_0_set as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let key_res_1_set: u32 = unsafe { ::std::mem::transmute(key_res_1_set) };
            key_res_1_set as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let f2_key_incr: u32 = unsafe { ::std::mem::transmute(f2_key_incr) };
            f2_key_incr as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let f2f4_token: u32 = unsafe { ::std::mem::transmute(f2f4_token) };
            f2f4_token as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let f3_tokens: u32 = unsafe { ::std::mem::transmute(f3_tokens) };
            f3_tokens as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_4"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_4>() - 12usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_4"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_4>() - 4usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_4::cond_r_key_0"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_4, cond_r_key_0) - 0usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_4::cond_r_key_1"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_4, cond_r_key_1) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt__bindgen_ty_5 {
    pub q_count: u32,
    pub __bindgen_anon_1: _ocsd_etmv4_i_pkt__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_5__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_5__bindgen_ty_1>() - 4usize];
};
impl _ocsd_etmv4_i_pkt__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn addr_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_addr_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addr_present_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_addr_present_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addr_match(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_addr_match(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addr_match_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_addr_match_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn count_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_count_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn count_present_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_count_present_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn q_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_q_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn q_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_q_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr_present: u32,
        addr_match: u32,
        count_present: u32,
        q_type: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let addr_present: u32 = unsafe { ::std::mem::transmute(addr_present) };
            addr_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let addr_match: u32 = unsafe { ::std::mem::transmute(addr_match) };
            addr_match as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let count_present: u32 = unsafe { ::std::mem::transmute(count_present) };
            count_present as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let q_type: u32 = unsafe { ::std::mem::transmute(q_type) };
            q_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_5"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_5>() - 8usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_5"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_5>() - 4usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_5::q_count"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_5, q_count) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt__bindgen_ty_6 {
    pub el: u8,
    pub value: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_6"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_6>() - 16usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_6"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_6>() - 8usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_6::el"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_6, el) - 0usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_6::value"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_6, value) - 8usize];
};
#[doc = "! valid bits for packet elements (addresses have their own valid bits)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ocsd_etmv4_i_pkt__bindgen_ty_7 {
    pub val: u32,
    pub bits: _ocsd_etmv4_i_pkt__bindgen_ty_7__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_i_pkt__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_7__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_7__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_7__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_7__bindgen_ty_1>() - 4usize];
};
impl _ocsd_etmv4_i_pkt__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn context_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_context_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn context_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_context_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ts_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ts_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ts_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ts_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spec_depth_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_spec_depth_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spec_depth_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_spec_depth_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn p0_key_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_p0_key_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn p0_key_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_p0_key_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cond_c_key_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cond_c_key_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cond_c_key_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cond_c_key_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cond_r_key_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cond_r_key_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cond_r_key_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cond_r_key_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn trace_info_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trace_info_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn trace_info_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_trace_info_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cc_thresh_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cc_thresh_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cc_thresh_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cc_thresh_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cc_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cc_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cc_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cc_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn commit_elem_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_commit_elem_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn commit_elem_valid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_commit_elem_valid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        context_valid: u32,
        ts_valid: u32,
        spec_depth_valid: u32,
        p0_key_valid: u32,
        cond_c_key_valid: u32,
        cond_r_key_valid: u32,
        trace_info_valid: u32,
        cc_thresh_valid: u32,
        cc_valid: u32,
        commit_elem_valid: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let context_valid: u32 = unsafe { ::std::mem::transmute(context_valid) };
            context_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ts_valid: u32 = unsafe { ::std::mem::transmute(ts_valid) };
            ts_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let spec_depth_valid: u32 = unsafe { ::std::mem::transmute(spec_depth_valid) };
            spec_depth_valid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let p0_key_valid: u32 = unsafe { ::std::mem::transmute(p0_key_valid) };
            p0_key_valid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cond_c_key_valid: u32 = unsafe { ::std::mem::transmute(cond_c_key_valid) };
            cond_c_key_valid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cond_r_key_valid: u32 = unsafe { ::std::mem::transmute(cond_r_key_valid) };
            cond_r_key_valid as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let trace_info_valid: u32 = unsafe { ::std::mem::transmute(trace_info_valid) };
            trace_info_valid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let cc_thresh_valid: u32 = unsafe { ::std::mem::transmute(cc_thresh_valid) };
            cc_thresh_valid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cc_valid: u32 = unsafe { ::std::mem::transmute(cc_valid) };
            cc_valid as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let commit_elem_valid: u32 = unsafe { ::std::mem::transmute(commit_elem_valid) };
            commit_elem_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt__bindgen_ty_7"]
        [::std::mem::size_of::<_ocsd_etmv4_i_pkt__bindgen_ty_7>() - 4usize];
    ["Alignment of _ocsd_etmv4_i_pkt__bindgen_ty_7"]
        [::std::mem::align_of::<_ocsd_etmv4_i_pkt__bindgen_ty_7>() - 4usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_7::val"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_7, val) - 0usize];
    ["Offset of field: _ocsd_etmv4_i_pkt__bindgen_ty_7::bits"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt__bindgen_ty_7, bits) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_i_pkt"][::std::mem::size_of::<_ocsd_etmv4_i_pkt>() - 176usize];
    ["Alignment of _ocsd_etmv4_i_pkt"][::std::mem::align_of::<_ocsd_etmv4_i_pkt>() - 8usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::type_"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, type_) - 0usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::v_addr"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, v_addr) - 8usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::v_addr_ISA"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, v_addr_ISA) - 32usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::context"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, context) - 36usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::ts"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, ts) - 48usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::cc_threshold"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, cc_threshold) - 64usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::atom"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, atom) - 68usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::cycle_count"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, cycle_count) - 76usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::curr_spec_depth"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, curr_spec_depth) - 80usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::p0_key"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, p0_key) - 84usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::commit_elements"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, commit_elements) - 88usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::cancel_elements"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, cancel_elements) - 92usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::trace_info"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, trace_info) - 96usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::exception_info"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, exception_info) - 100usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::addr_exact_match_idx"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, addr_exact_match_idx) - 104usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::dsm_val"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, dsm_val) - 105usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::event_val"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, event_val) - 106usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::cond_instr"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, cond_instr) - 108usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::cond_result"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, cond_result) - 120usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::Q_pkt"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, Q_pkt) - 132usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::ite_pkt"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, ite_pkt) - 144usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::pkt_valid"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, pkt_valid) - 160usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::err_type"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, err_type) - 164usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::err_hdr_val"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, err_hdr_val) - 168usize];
    ["Offset of field: _ocsd_etmv4_i_pkt::protocol_version"]
        [::std::mem::offset_of!(_ocsd_etmv4_i_pkt, protocol_version) - 169usize];
};
pub type ocsd_etmv4_i_pkt = _ocsd_etmv4_i_pkt;
#[doc = "!< no sync found yet"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_NOTSYNC: _ocsd_etmv4_d_pkt_type = 512;
#[doc = "!< invalid sequence for packet type"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_BAD_SEQUENCE: _ocsd_etmv4_d_pkt_type = 513;
#[doc = "!< invalid packet type for this trace mode."]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_BAD_TRACEMODE: _ocsd_etmv4_d_pkt_type = 514;
#[doc = "!< packet type reserved."]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_RESERVED: _ocsd_etmv4_d_pkt_type = 515;
#[doc = "!< flushing incomplete packet at end of trace."]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_INCOMPLETE_EOT: _ocsd_etmv4_d_pkt_type = 516;
#[doc = "!< waiting for a header byte"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_NO_HEADER: _ocsd_etmv4_d_pkt_type = 517;
#[doc = "!< error packet has no header based type. Use with unknown/res packet types."]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_NO_ERR_TYPE: _ocsd_etmv4_d_pkt_type = 518;
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DNUM_DS_MKR: _ocsd_etmv4_d_pkt_type = 273;
#[doc = "!< b00000000"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_EXTENSION: _ocsd_etmv4_d_pkt_type = 0;
#[doc = "!< b00000001"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DUNNUM_DS_MKR: _ocsd_etmv4_d_pkt_type = 1;
#[doc = "!< b00000100"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DEVENT: _ocsd_etmv4_d_pkt_type = 4;
#[doc = "!< b00000010"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DTIMESTAMP: _ocsd_etmv4_d_pkt_type = 2;
#[doc = "!< b0111xxxx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DADDR_P1_F1: _ocsd_etmv4_d_pkt_type = 112;
#[doc = "!< b10xxxxxx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DADDR_P1_F2: _ocsd_etmv4_d_pkt_type = 128;
#[doc = "!< b000101xx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DADDR_P1_F3: _ocsd_etmv4_d_pkt_type = 20;
#[doc = "!< b0110xxxx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DADDR_P1_F4: _ocsd_etmv4_d_pkt_type = 96;
#[doc = "!< b11111xxx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DADDR_P1_F5: _ocsd_etmv4_d_pkt_type = 248;
#[doc = "!< b1111011x"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DADDR_P1_F6: _ocsd_etmv4_d_pkt_type = 246;
#[doc = "!< b11110101"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DADDR_P1_F7: _ocsd_etmv4_d_pkt_type = 245;
#[doc = "!< b0010xxxx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DVAL_P2_F1: _ocsd_etmv4_d_pkt_type = 32;
#[doc = "!< b00110xxx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DVAL_P2_F2: _ocsd_etmv4_d_pkt_type = 48;
#[doc = "!< b010xxxxx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DVAL_P2_F3: _ocsd_etmv4_d_pkt_type = 64;
#[doc = "!< b000100xx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DVAL_P2_F4: _ocsd_etmv4_d_pkt_type = 16;
#[doc = "!< b00011xxx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DVAL_P2_F5: _ocsd_etmv4_d_pkt_type = 24;
#[doc = "!< b00111xxx"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DVAL_P2_F6: _ocsd_etmv4_d_pkt_type = 56;
#[doc = "!< b00000011"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DSUPPRESSION: _ocsd_etmv4_d_pkt_type = 3;
#[doc = "!< b00000001"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_DTRACE_INFO: _ocsd_etmv4_d_pkt_type = 257;
#[doc = "!< b00000000"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_ASYNC: _ocsd_etmv4_d_pkt_type = 256;
#[doc = "!< b00000011"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_DISCARD: _ocsd_etmv4_d_pkt_type = 259;
#[doc = "!< b00000101"]
pub const _ocsd_etmv4_d_pkt_type_ETM4_PKT_D_OVERFLOW: _ocsd_etmv4_d_pkt_type = 261;
pub type _ocsd_etmv4_d_pkt_type = ::std::os::raw::c_uint;
pub use self::_ocsd_etmv4_d_pkt_type as ocsd_etmv4_d_pkt_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_d_pkt {
    pub type_: ocsd_etmv4_d_pkt_type,
    pub d_addr: ocsd_pkt_vaddr,
    #[doc = "< Packet value -> data value, timestamp value, event value"]
    pub pkt_val: u64,
    pub err_type: ocsd_etmv4_d_pkt_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_d_pkt"][::std::mem::size_of::<_ocsd_etmv4_d_pkt>() - 48usize];
    ["Alignment of _ocsd_etmv4_d_pkt"][::std::mem::align_of::<_ocsd_etmv4_d_pkt>() - 8usize];
    ["Offset of field: _ocsd_etmv4_d_pkt::type_"]
        [::std::mem::offset_of!(_ocsd_etmv4_d_pkt, type_) - 0usize];
    ["Offset of field: _ocsd_etmv4_d_pkt::d_addr"]
        [::std::mem::offset_of!(_ocsd_etmv4_d_pkt, d_addr) - 8usize];
    ["Offset of field: _ocsd_etmv4_d_pkt::pkt_val"]
        [::std::mem::offset_of!(_ocsd_etmv4_d_pkt, pkt_val) - 32usize];
    ["Offset of field: _ocsd_etmv4_d_pkt::err_type"]
        [::std::mem::offset_of!(_ocsd_etmv4_d_pkt, err_type) - 40usize];
};
pub type ocsd_etmv4_d_pkt = _ocsd_etmv4_d_pkt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_etmv4_cfg {
    #[doc = "< ID0 register"]
    pub reg_idr0: u32,
    #[doc = "< ID1 register"]
    pub reg_idr1: u32,
    #[doc = "< ID2 register"]
    pub reg_idr2: u32,
    pub reg_idr8: u32,
    pub reg_idr9: u32,
    pub reg_idr10: u32,
    pub reg_idr11: u32,
    pub reg_idr12: u32,
    pub reg_idr13: u32,
    #[doc = "< Config Register"]
    pub reg_configr: u32,
    #[doc = "< Trace Stream ID register"]
    pub reg_traceidr: u32,
    #[doc = "< Architecture version"]
    pub arch_ver: ocsd_arch_version_t,
    #[doc = "< Core Profile"]
    pub core_prof: ocsd_core_profile_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_etmv4_cfg"][::std::mem::size_of::<_ocsd_etmv4_cfg>() - 52usize];
    ["Alignment of _ocsd_etmv4_cfg"][::std::mem::align_of::<_ocsd_etmv4_cfg>() - 4usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_idr0"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_idr0) - 0usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_idr1"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_idr1) - 4usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_idr2"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_idr2) - 8usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_idr8"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_idr8) - 12usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_idr9"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_idr9) - 16usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_idr10"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_idr10) - 20usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_idr11"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_idr11) - 24usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_idr12"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_idr12) - 28usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_idr13"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_idr13) - 32usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_configr"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_configr) - 36usize];
    ["Offset of field: _ocsd_etmv4_cfg::reg_traceidr"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, reg_traceidr) - 40usize];
    ["Offset of field: _ocsd_etmv4_cfg::arch_ver"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, arch_ver) - 44usize];
    ["Offset of field: _ocsd_etmv4_cfg::core_prof"]
        [::std::mem::offset_of!(_ocsd_etmv4_cfg, core_prof) - 48usize];
};
pub type ocsd_etmv4_cfg = _ocsd_etmv4_cfg;
#[doc = "!< no sync found yet"]
pub const _ocsd_ptm_pkt_type_PTM_PKT_NOTSYNC: _ocsd_ptm_pkt_type = 0;
#[doc = "!< flushing incomplete packet at end of trace."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_INCOMPLETE_EOT: _ocsd_ptm_pkt_type = 1;
#[doc = "!< no error base type packet."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_NOERROR: _ocsd_ptm_pkt_type = 2;
#[doc = "!< Branch address with optional exception."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_BRANCH_ADDRESS: _ocsd_ptm_pkt_type = 3;
#[doc = "!< Alignment Synchronisation."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_A_SYNC: _ocsd_ptm_pkt_type = 4;
#[doc = "!< Instruction sync with address."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_I_SYNC: _ocsd_ptm_pkt_type = 5;
#[doc = "!< trigger packet"]
pub const _ocsd_ptm_pkt_type_PTM_PKT_TRIGGER: _ocsd_ptm_pkt_type = 6;
#[doc = "!< Waypoint update."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_WPOINT_UPDATE: _ocsd_ptm_pkt_type = 7;
#[doc = "!< ignore packet."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_IGNORE: _ocsd_ptm_pkt_type = 8;
#[doc = "!< context id packet."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_CONTEXT_ID: _ocsd_ptm_pkt_type = 9;
#[doc = "!< VMID packet"]
pub const _ocsd_ptm_pkt_type_PTM_PKT_VMID: _ocsd_ptm_pkt_type = 10;
#[doc = "!< atom waypoint packet."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_ATOM: _ocsd_ptm_pkt_type = 11;
#[doc = "!< timestamp packet."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_TIMESTAMP: _ocsd_ptm_pkt_type = 12;
#[doc = "!< exception return."]
pub const _ocsd_ptm_pkt_type_PTM_PKT_EXCEPTION_RET: _ocsd_ptm_pkt_type = 13;
pub const _ocsd_ptm_pkt_type_PTM_PKT_BRANCH_OR_BYPASS_EOT: _ocsd_ptm_pkt_type = 14;
pub const _ocsd_ptm_pkt_type_PTM_PKT_TPIU_PAD_EOB: _ocsd_ptm_pkt_type = 15;
#[doc = "!< invalid sequence for packet type"]
pub const _ocsd_ptm_pkt_type_PTM_PKT_BAD_SEQUENCE: _ocsd_ptm_pkt_type = 16;
#[doc = "!< Reserved packet encoding"]
pub const _ocsd_ptm_pkt_type_PTM_PKT_RESERVED: _ocsd_ptm_pkt_type = 17;
#[doc = " @name PTM Packet Types\n@{"]
pub type _ocsd_ptm_pkt_type = ::std::os::raw::c_uint;
#[doc = " @name PTM Packet Types\n@{"]
pub use self::_ocsd_ptm_pkt_type as ocsd_ptm_pkt_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ptm_context_t {
    pub __bindgen_anon_1: _ptm_context_t__bindgen_ty_1,
    #[doc = "< Context ID"]
    pub ctxtID: u32,
    #[doc = "< VMID"]
    pub VMID: u8,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ptm_context_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ptm_context_t__bindgen_ty_1"]
        [::std::mem::size_of::<_ptm_context_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _ptm_context_t__bindgen_ty_1"]
        [::std::mem::align_of::<_ptm_context_t__bindgen_ty_1>() - 4usize];
};
impl _ptm_context_t__bindgen_ty_1 {
    #[inline]
    pub fn curr_alt_isa(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_curr_alt_isa(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn curr_alt_isa_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_curr_alt_isa_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn curr_NS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_curr_NS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn curr_NS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_curr_NS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn curr_Hyp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_curr_Hyp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn curr_Hyp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_curr_Hyp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn updated(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn updated_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_updated_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn updated_c(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn updated_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_updated_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn updated_v(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated_v(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn updated_v_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_updated_v_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        curr_alt_isa: u32,
        curr_NS: u32,
        curr_Hyp: u32,
        updated: u32,
        updated_c: u32,
        updated_v: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let curr_alt_isa: u32 = unsafe { ::std::mem::transmute(curr_alt_isa) };
            curr_alt_isa as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let curr_NS: u32 = unsafe { ::std::mem::transmute(curr_NS) };
            curr_NS as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let curr_Hyp: u32 = unsafe { ::std::mem::transmute(curr_Hyp) };
            curr_Hyp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let updated: u32 = unsafe { ::std::mem::transmute(updated) };
            updated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let updated_c: u32 = unsafe { ::std::mem::transmute(updated_c) };
            updated_c as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let updated_v: u32 = unsafe { ::std::mem::transmute(updated_v) };
            updated_v as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ptm_context_t"][::std::mem::size_of::<_ptm_context_t>() - 12usize];
    ["Alignment of _ptm_context_t"][::std::mem::align_of::<_ptm_context_t>() - 4usize];
    ["Offset of field: _ptm_context_t::ctxtID"]
        [::std::mem::offset_of!(_ptm_context_t, ctxtID) - 4usize];
    ["Offset of field: _ptm_context_t::VMID"]
        [::std::mem::offset_of!(_ptm_context_t, VMID) - 8usize];
};
pub type ptm_context_t = _ptm_context_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_ptm_excep {
    #[doc = "<  exception type."]
    pub type_: ocsd_armv7_exception,
    #[doc = "< exception as number"]
    pub number: u16,
    pub bits: _ocsd_ptm_excep__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_ptm_excep__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_ptm_excep__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_ptm_excep__bindgen_ty_1>() - 4usize];
    ["Alignment of _ocsd_ptm_excep__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_ptm_excep__bindgen_ty_1>() - 4usize];
};
impl _ocsd_ptm_excep__bindgen_ty_1 {
    #[inline]
    pub fn present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn present_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_present_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(present: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let present: u32 = unsafe { ::std::mem::transmute(present) };
            present as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_ptm_excep"][::std::mem::size_of::<_ocsd_ptm_excep>() - 12usize];
    ["Alignment of _ocsd_ptm_excep"][::std::mem::align_of::<_ocsd_ptm_excep>() - 4usize];
    ["Offset of field: _ocsd_ptm_excep::type_"]
        [::std::mem::offset_of!(_ocsd_ptm_excep, type_) - 0usize];
    ["Offset of field: _ocsd_ptm_excep::number"]
        [::std::mem::offset_of!(_ocsd_ptm_excep, number) - 4usize];
    ["Offset of field: _ocsd_ptm_excep::bits"]
        [::std::mem::offset_of!(_ocsd_ptm_excep, bits) - 8usize];
};
pub type ocsd_ptm_excep = _ocsd_ptm_excep;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_ptm_pkt {
    #[doc = "< Primary packet type."]
    pub type_: ocsd_ptm_pkt_type,
    #[doc = "< current ISA."]
    pub curr_isa: ocsd_isa,
    #[doc = "< previous ISA"]
    pub prev_isa: ocsd_isa,
    #[doc = "< current address."]
    pub addr: ocsd_pkt_vaddr,
    #[doc = "< current context."]
    pub context: ptm_context_t,
    pub atom: ocsd_pkt_atom,
    #[doc = "< reason for ISync Packet."]
    pub i_sync_reason: ocsd_iSync_reason,
    #[doc = "< cycle count value associated with this packet."]
    pub cycle_count: u32,
    #[doc = "< cycle count value valid."]
    pub cc_valid: u8,
    #[doc = "< timestamp value."]
    pub timestamp: u64,
    #[doc = "< bits of ts updated this packet. (if TS packet)"]
    pub ts_update_bits: u8,
    #[doc = "< exception information in packet"]
    pub exception: ocsd_ptm_excep,
    #[doc = "< Basic packet type if primary type indicates error or incomplete."]
    pub err_type: ocsd_ptm_pkt_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_ptm_pkt"][::std::mem::size_of::<_ocsd_ptm_pkt>() - 104usize];
    ["Alignment of _ocsd_ptm_pkt"][::std::mem::align_of::<_ocsd_ptm_pkt>() - 8usize];
    ["Offset of field: _ocsd_ptm_pkt::type_"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, type_) - 0usize];
    ["Offset of field: _ocsd_ptm_pkt::curr_isa"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, curr_isa) - 4usize];
    ["Offset of field: _ocsd_ptm_pkt::prev_isa"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, prev_isa) - 8usize];
    ["Offset of field: _ocsd_ptm_pkt::addr"][::std::mem::offset_of!(_ocsd_ptm_pkt, addr) - 16usize];
    ["Offset of field: _ocsd_ptm_pkt::context"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, context) - 40usize];
    ["Offset of field: _ocsd_ptm_pkt::atom"][::std::mem::offset_of!(_ocsd_ptm_pkt, atom) - 52usize];
    ["Offset of field: _ocsd_ptm_pkt::i_sync_reason"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, i_sync_reason) - 60usize];
    ["Offset of field: _ocsd_ptm_pkt::cycle_count"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, cycle_count) - 64usize];
    ["Offset of field: _ocsd_ptm_pkt::cc_valid"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, cc_valid) - 68usize];
    ["Offset of field: _ocsd_ptm_pkt::timestamp"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, timestamp) - 72usize];
    ["Offset of field: _ocsd_ptm_pkt::ts_update_bits"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, ts_update_bits) - 80usize];
    ["Offset of field: _ocsd_ptm_pkt::exception"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, exception) - 84usize];
    ["Offset of field: _ocsd_ptm_pkt::err_type"]
        [::std::mem::offset_of!(_ocsd_ptm_pkt, err_type) - 96usize];
};
pub type ocsd_ptm_pkt = _ocsd_ptm_pkt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_ptm_cfg {
    #[doc = "< PTM ID register"]
    pub reg_idr: u32,
    #[doc = "< Control Register"]
    pub reg_ctrl: u32,
    #[doc = "< Condition code extension register"]
    pub reg_ccer: u32,
    #[doc = "< CoreSight Trace ID register"]
    pub reg_trc_id: u32,
    #[doc = "< Architecture version"]
    pub arch_ver: ocsd_arch_version_t,
    #[doc = "< Core Profile"]
    pub core_prof: ocsd_core_profile_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_ptm_cfg"][::std::mem::size_of::<_ocsd_ptm_cfg>() - 24usize];
    ["Alignment of _ocsd_ptm_cfg"][::std::mem::align_of::<_ocsd_ptm_cfg>() - 4usize];
    ["Offset of field: _ocsd_ptm_cfg::reg_idr"]
        [::std::mem::offset_of!(_ocsd_ptm_cfg, reg_idr) - 0usize];
    ["Offset of field: _ocsd_ptm_cfg::reg_ctrl"]
        [::std::mem::offset_of!(_ocsd_ptm_cfg, reg_ctrl) - 4usize];
    ["Offset of field: _ocsd_ptm_cfg::reg_ccer"]
        [::std::mem::offset_of!(_ocsd_ptm_cfg, reg_ccer) - 8usize];
    ["Offset of field: _ocsd_ptm_cfg::reg_trc_id"]
        [::std::mem::offset_of!(_ocsd_ptm_cfg, reg_trc_id) - 12usize];
    ["Offset of field: _ocsd_ptm_cfg::arch_ver"]
        [::std::mem::offset_of!(_ocsd_ptm_cfg, arch_ver) - 16usize];
    ["Offset of field: _ocsd_ptm_cfg::core_prof"]
        [::std::mem::offset_of!(_ocsd_ptm_cfg, core_prof) - 20usize];
};
pub type ocsd_ptm_cfg = _ocsd_ptm_cfg;
#[doc = "< Not synchronised"]
pub const _ocsd_stm_pkt_type_STM_PKT_NOTSYNC: _ocsd_stm_pkt_type = 0;
#[doc = "< Incomplete packet flushed at end of trace."]
pub const _ocsd_stm_pkt_type_STM_PKT_INCOMPLETE_EOT: _ocsd_stm_pkt_type = 1;
#[doc = "< No error in error packet marker."]
pub const _ocsd_stm_pkt_type_STM_PKT_NO_ERR_TYPE: _ocsd_stm_pkt_type = 2;
#[doc = "< Alignment synchronisation packet"]
pub const _ocsd_stm_pkt_type_STM_PKT_ASYNC: _ocsd_stm_pkt_type = 3;
#[doc = "< Version packet"]
pub const _ocsd_stm_pkt_type_STM_PKT_VERSION: _ocsd_stm_pkt_type = 4;
#[doc = "< Frequency packet"]
pub const _ocsd_stm_pkt_type_STM_PKT_FREQ: _ocsd_stm_pkt_type = 5;
#[doc = "< Null packet"]
pub const _ocsd_stm_pkt_type_STM_PKT_NULL: _ocsd_stm_pkt_type = 6;
#[doc = "< Trigger event packet."]
pub const _ocsd_stm_pkt_type_STM_PKT_TRIG: _ocsd_stm_pkt_type = 7;
#[doc = "< Global error packet - protocol error but unknown which master had error"]
pub const _ocsd_stm_pkt_type_STM_PKT_GERR: _ocsd_stm_pkt_type = 8;
#[doc = "< Master error packet - current master detected an error (e.g. dropped trace)"]
pub const _ocsd_stm_pkt_type_STM_PKT_MERR: _ocsd_stm_pkt_type = 9;
#[doc = "< Set current master"]
pub const _ocsd_stm_pkt_type_STM_PKT_M8: _ocsd_stm_pkt_type = 10;
#[doc = "< Set lower 8 bits of current channel"]
pub const _ocsd_stm_pkt_type_STM_PKT_C8: _ocsd_stm_pkt_type = 11;
#[doc = "< Set current channel"]
pub const _ocsd_stm_pkt_type_STM_PKT_C16: _ocsd_stm_pkt_type = 12;
#[doc = "< Flag packet"]
pub const _ocsd_stm_pkt_type_STM_PKT_FLAG: _ocsd_stm_pkt_type = 13;
#[doc = "< 4 bit data payload packet"]
pub const _ocsd_stm_pkt_type_STM_PKT_D4: _ocsd_stm_pkt_type = 14;
#[doc = "< 8 bit data payload packet"]
pub const _ocsd_stm_pkt_type_STM_PKT_D8: _ocsd_stm_pkt_type = 15;
#[doc = "< 16 bit data payload packet"]
pub const _ocsd_stm_pkt_type_STM_PKT_D16: _ocsd_stm_pkt_type = 16;
#[doc = "< 32 bit data payload packet"]
pub const _ocsd_stm_pkt_type_STM_PKT_D32: _ocsd_stm_pkt_type = 17;
#[doc = "< 64 bit data payload packet"]
pub const _ocsd_stm_pkt_type_STM_PKT_D64: _ocsd_stm_pkt_type = 18;
#[doc = "< Incorrect protocol sequence"]
pub const _ocsd_stm_pkt_type_STM_PKT_BAD_SEQUENCE: _ocsd_stm_pkt_type = 19;
#[doc = "< Reserved packet header / not supported by CS-STM"]
pub const _ocsd_stm_pkt_type_STM_PKT_RESERVED: _ocsd_stm_pkt_type = 20;
#[doc = " STM protocol packet types.\nContains both protocol packet types and markers for unsynced processor\nstate and bad packet sequences."]
pub type _ocsd_stm_pkt_type = ::std::os::raw::c_uint;
#[doc = " STM protocol packet types.\nContains both protocol packet types and markers for unsynced processor\nstate and bad packet sequences."]
pub use self::_ocsd_stm_pkt_type as ocsd_stm_pkt_type;
#[doc = "< TS encoding unknown at present."]
pub const _ocsd_stm_ts_type_STM_TS_UNKNOWN: _ocsd_stm_ts_type = 0;
#[doc = "< TS encoding natural binary"]
pub const _ocsd_stm_ts_type_STM_TS_NATBINARY: _ocsd_stm_ts_type = 1;
#[doc = "< TS encoding grey coded."]
pub const _ocsd_stm_ts_type_STM_TS_GREY: _ocsd_stm_ts_type = 2;
#[doc = " STM timestamp encoding type.\nExtracted from STM version packet.\nCS-STM supports Natural binary and grey encodings."]
pub type _ocsd_stm_ts_type = ::std::os::raw::c_uint;
#[doc = " STM timestamp encoding type.\nExtracted from STM version packet.\nCS-STM supports Natural binary and grey encodings."]
pub use self::_ocsd_stm_ts_type as ocsd_stm_ts_type;
#[doc = " STM trace packet\n\nStructure containing the packet data for a single STM packet, plus\ndata persisting between packets (master, channel, last timestamp)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ocsd_stm_pkt {
    #[doc = "< STM packet type"]
    pub type_: ocsd_stm_pkt_type,
    #[doc = "< current master"]
    pub master: u8,
    #[doc = "< current channel"]
    pub channel: u16,
    #[doc = "< latest timestamp value -> as binary - packet processor does grey decoding"]
    pub timestamp: u64,
    #[doc = "< timestamp bits updated this packet"]
    pub pkt_ts_bits: u8,
    #[doc = "< current packet has associated timestamp (ts bits can be 0 if same value as last time)"]
    pub pkt_has_ts: u8,
    #[doc = "< timestamp encoding type"]
    pub ts_type: ocsd_stm_ts_type,
    #[doc = "< flag to indicate current packet has marker"]
    pub pkt_has_marker: u8,
    pub payload: _ocsd_stm_pkt__bindgen_ty_1,
    #[doc = "< Initial type of packet if type indicates bad sequence."]
    pub err_type: ocsd_stm_pkt_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ocsd_stm_pkt__bindgen_ty_1 {
    #[doc = "< payload for D8 or D4 data packet, or parameter value for other packets with 8 bit value [VERSION, TRIG, xERR]"]
    pub D8: u8,
    #[doc = "< payload for D16 data packet, or reserved opcode in bad packet header (1-3 nibbles)"]
    pub D16: u16,
    #[doc = "< payload for D32 data packet, or parameter value for other packets with 32 bit value [FREQ]"]
    pub D32: u32,
    #[doc = "< payload for D64 data packet"]
    pub D64: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_stm_pkt__bindgen_ty_1"]
        [::std::mem::size_of::<_ocsd_stm_pkt__bindgen_ty_1>() - 8usize];
    ["Alignment of _ocsd_stm_pkt__bindgen_ty_1"]
        [::std::mem::align_of::<_ocsd_stm_pkt__bindgen_ty_1>() - 8usize];
    ["Offset of field: _ocsd_stm_pkt__bindgen_ty_1::D8"]
        [::std::mem::offset_of!(_ocsd_stm_pkt__bindgen_ty_1, D8) - 0usize];
    ["Offset of field: _ocsd_stm_pkt__bindgen_ty_1::D16"]
        [::std::mem::offset_of!(_ocsd_stm_pkt__bindgen_ty_1, D16) - 0usize];
    ["Offset of field: _ocsd_stm_pkt__bindgen_ty_1::D32"]
        [::std::mem::offset_of!(_ocsd_stm_pkt__bindgen_ty_1, D32) - 0usize];
    ["Offset of field: _ocsd_stm_pkt__bindgen_ty_1::D64"]
        [::std::mem::offset_of!(_ocsd_stm_pkt__bindgen_ty_1, D64) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_stm_pkt"][::std::mem::size_of::<_ocsd_stm_pkt>() - 48usize];
    ["Alignment of _ocsd_stm_pkt"][::std::mem::align_of::<_ocsd_stm_pkt>() - 8usize];
    ["Offset of field: _ocsd_stm_pkt::type_"]
        [::std::mem::offset_of!(_ocsd_stm_pkt, type_) - 0usize];
    ["Offset of field: _ocsd_stm_pkt::master"]
        [::std::mem::offset_of!(_ocsd_stm_pkt, master) - 4usize];
    ["Offset of field: _ocsd_stm_pkt::channel"]
        [::std::mem::offset_of!(_ocsd_stm_pkt, channel) - 6usize];
    ["Offset of field: _ocsd_stm_pkt::timestamp"]
        [::std::mem::offset_of!(_ocsd_stm_pkt, timestamp) - 8usize];
    ["Offset of field: _ocsd_stm_pkt::pkt_ts_bits"]
        [::std::mem::offset_of!(_ocsd_stm_pkt, pkt_ts_bits) - 16usize];
    ["Offset of field: _ocsd_stm_pkt::pkt_has_ts"]
        [::std::mem::offset_of!(_ocsd_stm_pkt, pkt_has_ts) - 17usize];
    ["Offset of field: _ocsd_stm_pkt::ts_type"]
        [::std::mem::offset_of!(_ocsd_stm_pkt, ts_type) - 20usize];
    ["Offset of field: _ocsd_stm_pkt::pkt_has_marker"]
        [::std::mem::offset_of!(_ocsd_stm_pkt, pkt_has_marker) - 24usize];
    ["Offset of field: _ocsd_stm_pkt::payload"]
        [::std::mem::offset_of!(_ocsd_stm_pkt, payload) - 32usize];
    ["Offset of field: _ocsd_stm_pkt::err_type"]
        [::std::mem::offset_of!(_ocsd_stm_pkt, err_type) - 40usize];
};
#[doc = " STM trace packet\n\nStructure containing the packet data for a single STM packet, plus\ndata persisting between packets (master, channel, last timestamp)."]
pub type ocsd_stm_pkt = _ocsd_stm_pkt;
#[doc = "< status of HW event features not known - assume not present or disabled"]
pub const _hw_event_feat_HwEvent_Unknown_Disabled: _hw_event_feat = 0;
#[doc = "< HW event present and enabled - ignore Feat regs, assume hwev_mast value valid"]
pub const _hw_event_feat_HwEvent_Enabled: _hw_event_feat = 1;
#[doc = "< Feature Register values and enable bits used to determine HW event trace status"]
pub const _hw_event_feat_HwEvent_UseRegisters: _hw_event_feat = 2;
#[doc = " HW Event trace feature\nDefines if the STM supports or has enabled the HW event trace feature.\nThis may not always be able to be determined by the registers, or the feature\nvalues can override if HW event trace is to be ignored."]
pub type _hw_event_feat = ::std::os::raw::c_uint;
#[doc = " HW Event trace feature\nDefines if the STM supports or has enabled the HW event trace feature.\nThis may not always be able to be determined by the registers, or the feature\nvalues can override if HW event trace is to be ignored."]
pub use self::_hw_event_feat as hw_event_feat_t;
#[doc = " STM hardware configuration.\nContains hardware register values at time of trace capture and HW event feature\nfield to enable and control decode of STM trace stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_stm_cfg {
    #[doc = "< Contains CoreSight trace ID, HWTEN"]
    pub reg_tcsr: u32,
    #[doc = "< defines number of masters"]
    pub reg_feat3r: u32,
    #[doc = "< defines number of channels per master"]
    pub reg_devid: u32,
    #[doc = "< defines HW trace features"]
    pub reg_feat1r: u32,
    #[doc = "< master ID for HW event trace"]
    pub reg_hwev_mast: u32,
    #[doc = "< status of HW event trace"]
    pub hw_event: hw_event_feat_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_stm_cfg"][::std::mem::size_of::<_ocsd_stm_cfg>() - 24usize];
    ["Alignment of _ocsd_stm_cfg"][::std::mem::align_of::<_ocsd_stm_cfg>() - 4usize];
    ["Offset of field: _ocsd_stm_cfg::reg_tcsr"]
        [::std::mem::offset_of!(_ocsd_stm_cfg, reg_tcsr) - 0usize];
    ["Offset of field: _ocsd_stm_cfg::reg_feat3r"]
        [::std::mem::offset_of!(_ocsd_stm_cfg, reg_feat3r) - 4usize];
    ["Offset of field: _ocsd_stm_cfg::reg_devid"]
        [::std::mem::offset_of!(_ocsd_stm_cfg, reg_devid) - 8usize];
    ["Offset of field: _ocsd_stm_cfg::reg_feat1r"]
        [::std::mem::offset_of!(_ocsd_stm_cfg, reg_feat1r) - 12usize];
    ["Offset of field: _ocsd_stm_cfg::reg_hwev_mast"]
        [::std::mem::offset_of!(_ocsd_stm_cfg, reg_hwev_mast) - 16usize];
    ["Offset of field: _ocsd_stm_cfg::hw_event"]
        [::std::mem::offset_of!(_ocsd_stm_cfg, hw_event) - 20usize];
};
#[doc = " STM hardware configuration.\nContains hardware register values at time of trace capture and HW event feature\nfield to enable and control decode of STM trace stream."]
pub type ocsd_stm_cfg = _ocsd_stm_cfg;
#[doc = " @name ETE config Types\n@{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_ete_cfg {
    #[doc = "< ID0 register"]
    pub reg_idr0: u32,
    #[doc = "< ID1 register"]
    pub reg_idr1: u32,
    #[doc = "< ID2 register"]
    pub reg_idr2: u32,
    #[doc = "< ID8 - maxspec"]
    pub reg_idr8: u32,
    #[doc = "< DevArch register"]
    pub reg_devarch: u32,
    #[doc = "< Config Register"]
    pub reg_configr: u32,
    #[doc = "< Trace Stream ID register"]
    pub reg_traceidr: u32,
    #[doc = "< Architecture version"]
    pub arch_ver: ocsd_arch_version_t,
    #[doc = "< Core Profile"]
    pub core_prof: ocsd_core_profile_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_ete_cfg"][::std::mem::size_of::<_ocsd_ete_cfg>() - 36usize];
    ["Alignment of _ocsd_ete_cfg"][::std::mem::align_of::<_ocsd_ete_cfg>() - 4usize];
    ["Offset of field: _ocsd_ete_cfg::reg_idr0"]
        [::std::mem::offset_of!(_ocsd_ete_cfg, reg_idr0) - 0usize];
    ["Offset of field: _ocsd_ete_cfg::reg_idr1"]
        [::std::mem::offset_of!(_ocsd_ete_cfg, reg_idr1) - 4usize];
    ["Offset of field: _ocsd_ete_cfg::reg_idr2"]
        [::std::mem::offset_of!(_ocsd_ete_cfg, reg_idr2) - 8usize];
    ["Offset of field: _ocsd_ete_cfg::reg_idr8"]
        [::std::mem::offset_of!(_ocsd_ete_cfg, reg_idr8) - 12usize];
    ["Offset of field: _ocsd_ete_cfg::reg_devarch"]
        [::std::mem::offset_of!(_ocsd_ete_cfg, reg_devarch) - 16usize];
    ["Offset of field: _ocsd_ete_cfg::reg_configr"]
        [::std::mem::offset_of!(_ocsd_ete_cfg, reg_configr) - 20usize];
    ["Offset of field: _ocsd_ete_cfg::reg_traceidr"]
        [::std::mem::offset_of!(_ocsd_ete_cfg, reg_traceidr) - 24usize];
    ["Offset of field: _ocsd_ete_cfg::arch_ver"]
        [::std::mem::offset_of!(_ocsd_ete_cfg, arch_ver) - 28usize];
    ["Offset of field: _ocsd_ete_cfg::core_prof"]
        [::std::mem::offset_of!(_ocsd_ete_cfg, core_prof) - 32usize];
};
#[doc = " @name ETE config Types\n@{"]
pub type ocsd_ete_cfg = _ocsd_ete_cfg;
#[doc = " Handle to decode tree"]
pub type dcd_tree_handle_t = *mut ::std::os::raw::c_void;
#[doc = " function pointer type for decoder outputs. all protocols, generic data element input"]
pub type FnTraceElemIn = ::std::option::Option<
    unsafe extern "C" fn(
        p_context: *const ::std::os::raw::c_void,
        index_sop: ocsd_trc_index_t,
        trc_chan_id: u8,
        elem: *const ocsd_generic_trace_elem,
    ) -> ocsd_datapath_resp_t,
>;
#[doc = " function pointer type for packet processor packet output sink, packet analyser/decoder input - generic declaration"]
pub type FnDefPktDataIn = ::std::option::Option<
    unsafe extern "C" fn(
        p_context: *const ::std::os::raw::c_void,
        op: ocsd_datapath_op_t,
        index_sop: ocsd_trc_index_t,
        p_packet_in: *const ::std::os::raw::c_void,
    ) -> ocsd_datapath_resp_t,
>;
#[doc = " function pointer type for packet processor packet monitor sink, raw packet monitor / display input - generic declaration"]
pub type FnDefPktDataMon = ::std::option::Option<
    unsafe extern "C" fn(
        p_context: *const ::std::os::raw::c_void,
        op: ocsd_datapath_op_t,
        index_sop: ocsd_trc_index_t,
        p_packet_in: *const ::std::os::raw::c_void,
        size: u32,
        p_data: *const u8,
    ),
>;
#[doc = " function pointer tyee for library default logger output to allow client to print zero terminated output string"]
pub type FnDefLoggerPrintStrCB = ::std::option::Option<
    unsafe extern "C" fn(
        p_context: *const ::std::os::raw::c_void,
        psz_msg_str: *const ::std::os::raw::c_char,
        str_len: ::std::os::raw::c_int,
    ),
>;
pub const _ocsd_c_api_cb_types_OCSD_C_API_CB_PKT_SINK: _ocsd_c_api_cb_types = 0;
#[doc = " Attach to the packet processor primary packet output (CB fn is FnDefPktDataIn)"]
pub const _ocsd_c_api_cb_types_OCSD_C_API_CB_PKT_MON: _ocsd_c_api_cb_types = 1;
#[doc = " Callback interface type when attaching monitor/sink to packet processor"]
pub type _ocsd_c_api_cb_types = ::std::os::raw::c_uint;
#[doc = " Callback interface type when attaching monitor/sink to packet processor"]
pub use self::_ocsd_c_api_cb_types as ocsd_c_api_cb_types;
#[doc = " Raw trace data input function - a decoder must have one of these\nImplements ITrcDataIn with the addition of a decoder handle to provide context in the decoder."]
pub type fnTraceDataIn = ::std::option::Option<
    unsafe extern "C" fn(
        decoder_handle: *const ::std::os::raw::c_void,
        op: ocsd_datapath_op_t,
        index: ocsd_trc_index_t,
        dataBlockSize: u32,
        pDataBlock: *const u8,
        numBytesProcessed: *mut u32,
    ) -> ocsd_datapath_resp_t,
>;
#[doc = " Function to update the in-use flags for the packet sinks\n\nDefines if the fnPktMonCB or fnPktDataSinkCB callbacks are in use by the library.\nIf so then it is expected that the decoder should call them when trace protocol packets are generated.\n\nThis function must be implemented in the decoder.\n\n@param decoder_handle : handle for decoder accessed by this call.\n@param flags: Values indicating interfaces in use / not in use. [ OCSD_CUST_DCD_PKT_CB_USE_MON or  OCSD_CUST_DCD_PKT_CB_USE_SINK]"]
pub type fnUpdatePktMonFlags = ::std::option::Option<
    unsafe extern "C" fn(
        decoder_handle: *const ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ),
>;
#[doc = " Owned by the library instance object, this structure is filled in by the ocsd_extern_dcd_fact_t createDecoder() function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_extern_dcd_inst {
    #[doc = "< raw trace data input function to decoder"]
    pub fn_data_in: fnTraceDataIn,
    #[doc = "< update the packet monitor / sink usage flags"]
    pub fn_update_pkt_mon: fnUpdatePktMonFlags,
    #[doc = "< Instance handle for the decoder  - used by library to call the decoder call in functions"]
    pub decoder_handle: *mut ::std::os::raw::c_void,
    #[doc = "< type name of the decoder - may be used in logging"]
    pub p_decoder_name: *mut ::std::os::raw::c_char,
    #[doc = "< Coresight ID for the instance - extracted from the config on creation."]
    pub cs_id: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_extern_dcd_inst"][::std::mem::size_of::<_ocsd_extern_dcd_inst>() - 40usize];
    ["Alignment of _ocsd_extern_dcd_inst"]
        [::std::mem::align_of::<_ocsd_extern_dcd_inst>() - 8usize];
    ["Offset of field: _ocsd_extern_dcd_inst::fn_data_in"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_inst, fn_data_in) - 0usize];
    ["Offset of field: _ocsd_extern_dcd_inst::fn_update_pkt_mon"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_inst, fn_update_pkt_mon) - 8usize];
    ["Offset of field: _ocsd_extern_dcd_inst::decoder_handle"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_inst, decoder_handle) - 16usize];
    ["Offset of field: _ocsd_extern_dcd_inst::p_decoder_name"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_inst, p_decoder_name) - 24usize];
    ["Offset of field: _ocsd_extern_dcd_inst::cs_id"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_inst, cs_id) - 32usize];
};
#[doc = " Owned by the library instance object, this structure is filled in by the ocsd_extern_dcd_fact_t createDecoder() function."]
pub type ocsd_extern_dcd_inst_t = _ocsd_extern_dcd_inst;
#[doc = " callback function to connect into the generic element output point\nImplements ITrcGenElemIn::TraceElemIn with addition of library context pointer."]
pub type fnGenElemOpCB = ::std::option::Option<
    unsafe extern "C" fn(
        lib_context: *const ::std::os::raw::c_void,
        index_sop: ocsd_trc_index_t,
        trc_chan_id: u8,
        elem: *const ocsd_generic_trace_elem,
    ) -> ocsd_datapath_resp_t,
>;
#[doc = " callback functions to connect into the library error logging mechanism\nImplements ITraceErrorLog::LogError with addition of library context pointer."]
pub type fnLogErrorCB = ::std::option::Option<
    unsafe extern "C" fn(
        lib_context: *const ::std::os::raw::c_void,
        filter_level: ocsd_err_severity_t,
        code: ocsd_err_t,
        idx: ocsd_trc_index_t,
        chan_id: u8,
        pMsg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " callback functions to connect into the library error logging mechanism\nImplements ITraceErrorLog::LogMessage with addition of library context pointer."]
pub type fnLogMsgCB = ::std::option::Option<
    unsafe extern "C" fn(
        lib_context: *const ::std::os::raw::c_void,
        filter_level: ocsd_err_severity_t,
        msg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " callback function to connect an ARM instruction decoder\nImplements IInstrDecode::DecodeInstruction with addition of library context pointer."]
pub type fnDecodeArmInstCB = ::std::option::Option<
    unsafe extern "C" fn(
        lib_context: *const ::std::os::raw::c_void,
        instr_info: *mut ocsd_instr_info,
    ) -> ocsd_err_t,
>;
#[doc = " callback function to connect the memory accessor interface\nImplements ITargetMemAccess::ReadTargetMemory with addition of library context pointer."]
pub type fnMemAccessCB = ::std::option::Option<
    unsafe extern "C" fn(
        lib_context: *const ::std::os::raw::c_void,
        address: ocsd_vaddr_t,
        cs_trace_id: u8,
        mem_space: ocsd_mem_space_acc_t,
        num_bytes: *mut u32,
        p_buffer: *mut u8,
    ) -> ocsd_err_t,
>;
#[doc = " callback function to connect to the packet monitor interface of the packet processor\nImplements IPktRawDataMon::RawPacketDataMon <void> with addition of library context pointer."]
pub type fnPktMonCB = ::std::option::Option<
    unsafe extern "C" fn(
        lib_context: *const ::std::os::raw::c_void,
        op: ocsd_datapath_op_t,
        index_sop: ocsd_trc_index_t,
        pkt: *const ::std::os::raw::c_void,
        size: u32,
        p_data: *const u8,
    ),
>;
#[doc = " callback function to connect to the packet sink interface, on the main decode\ndata path - use if decoder created as packet processor only\n\nImplements IPktDataIn::PacketDataIn <void> with addition of library context pointer."]
pub type fnPktDataSinkCB = ::std::option::Option<
    unsafe extern "C" fn(
        lib_context: *const ::std::os::raw::c_void,
        op: ocsd_datapath_op_t,
        index_sop: ocsd_trc_index_t,
        pkt: *const ::std::os::raw::c_void,
    ) -> ocsd_datapath_resp_t,
>;
#[doc = " an instance of this is owned by the decoder, filled in by the library - allows the CB fns in the library decode tree to be called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_extern_dcd_cb_fns {
    #[doc = "< Callback to output a generic element."]
    pub fn_gen_elem_out: fnGenElemOpCB,
    #[doc = "< Callback to output an error."]
    pub fn_log_error: fnLogErrorCB,
    #[doc = "< Callback to output a message."]
    pub fn_log_msg: fnLogMsgCB,
    #[doc = "< Callback to decode an ARM instruction."]
    pub fn_arm_instruction_decode: fnDecodeArmInstCB,
    #[doc = "< Callback to access memory images related to the trace capture."]
    pub fn_memory_access: fnMemAccessCB,
    #[doc = "< Callback to output trace packet to packet monitor."]
    pub fn_packet_mon: fnPktMonCB,
    #[doc = "< Callback to output trace packet to packet sink - if in pack processing only mode."]
    pub fn_packet_data_sink: fnPktDataSinkCB,
    #[doc = "< Flags to indicate if the packet sink / packet monitor callbacks are in use. ( OCSD_CUST_DCD_PKT_CB_USE_MON / OCSD_CUST_DCD_PKT_CB_USE_SINK)"]
    pub packetCBFlags: ::std::os::raw::c_int,
    #[doc = "< library context pointer - use in callbacks to allow the library to load the correct context data."]
    pub lib_context: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_extern_dcd_cb_fns"][::std::mem::size_of::<_ocsd_extern_dcd_cb_fns>() - 72usize];
    ["Alignment of _ocsd_extern_dcd_cb_fns"]
        [::std::mem::align_of::<_ocsd_extern_dcd_cb_fns>() - 8usize];
    ["Offset of field: _ocsd_extern_dcd_cb_fns::fn_gen_elem_out"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_cb_fns, fn_gen_elem_out) - 0usize];
    ["Offset of field: _ocsd_extern_dcd_cb_fns::fn_log_error"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_cb_fns, fn_log_error) - 8usize];
    ["Offset of field: _ocsd_extern_dcd_cb_fns::fn_log_msg"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_cb_fns, fn_log_msg) - 16usize];
    ["Offset of field: _ocsd_extern_dcd_cb_fns::fn_arm_instruction_decode"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_cb_fns, fn_arm_instruction_decode) - 24usize];
    ["Offset of field: _ocsd_extern_dcd_cb_fns::fn_memory_access"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_cb_fns, fn_memory_access) - 32usize];
    ["Offset of field: _ocsd_extern_dcd_cb_fns::fn_packet_mon"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_cb_fns, fn_packet_mon) - 40usize];
    ["Offset of field: _ocsd_extern_dcd_cb_fns::fn_packet_data_sink"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_cb_fns, fn_packet_data_sink) - 48usize];
    ["Offset of field: _ocsd_extern_dcd_cb_fns::packetCBFlags"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_cb_fns, packetCBFlags) - 56usize];
    ["Offset of field: _ocsd_extern_dcd_cb_fns::lib_context"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_cb_fns, lib_context) - 64usize];
};
#[doc = " an instance of this is owned by the decoder, filled in by the library - allows the CB fns in the library decode tree to be called."]
pub type ocsd_extern_dcd_cb_fns = _ocsd_extern_dcd_cb_fns;
#[doc = " Function to create a decoder instance\n\nCreate a decoder instance according to the create_flags parameter and the supplied decoder_cfg structure.\nFill in the p_decoder_inst structure, copy the p_lib_callbacks information for use in the decoder instance.\n\nCreate flags can be:\n- OCSD_CREATE_FLG_PACKET_PROC: decoder will split the incoming trace into trace protocol packets and not further decode them. fnPktDataSinkCB likely to be in use.\n- OCSD_CREATE_FLG_FULL_DECODER: decoder will split the incoming trace into trace protocol packets and further decode them to recreate program flow or other generic trace output.\n\n@param create_flags : Sets the decoder operating mode.\n@param *decoder_cfg : Hardware specific configuration for this trace element.\n@param *p_lib_callbacks : Library callbacks plus context pointer.\n@param *p_decoder_inst : Structure representing the new decoder instance being created. Filled in by create function to contain handle and call-in functions for the library.\n\n@return ocsd_err_t  : Library error code -  RCDTL_OK if successful"]
pub type fnCreateCustomDecoder = ::std::option::Option<
    unsafe extern "C" fn(
        create_flags: ::std::os::raw::c_int,
        decoder_cfg: *const ::std::os::raw::c_void,
        p_lib_callbacks: *const ocsd_extern_dcd_cb_fns,
        p_decoder_inst: *mut ocsd_extern_dcd_inst_t,
    ) -> ocsd_err_t,
>;
#[doc = " Function to destroy a decoder instance indicated by decoder handle.\n\n@param decoder_handle : Instance handle for decoder.\n\n@return ocsd_err_t  : Library error code -  RCDTL_OK if successful"]
pub type fnDestroyCustomDecoder = ::std::option::Option<
    unsafe extern "C" fn(decoder_handle: *const ::std::os::raw::c_void) -> ocsd_err_t,
>;
#[doc = " Function to extract the CoreSight Trace ID from the configuration structure.\n\n@param *decoder_cfg : Hardware specific configuration for this trace element.\n@parma *p_csid : location to write CoreSight Trace ID value.\n\n@return ocsd_err_t  : Library error code -  RCDTL_OK if successful"]
pub type fnGetCSIDFromConfig = ::std::option::Option<
    unsafe extern "C" fn(
        decoder_cfg: *const ::std::os::raw::c_void,
        p_csid: *mut ::std::os::raw::c_uchar,
    ) -> ocsd_err_t,
>;
#[doc = " Function to convert a protocol specific trace packet to human readable string\n\n@param *trc_pkt : protocol specific packet structure.\n@param *buffer  : buffer to fill with string.\n@param  buflen  : length of string buffer.\n\n@return ocsd_err_t  : Library error code -  RCDTL_OK if successful"]
pub type fnPacketToString = ::std::option::Option<
    unsafe extern "C" fn(
        trc_pkt: *const ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ocsd_err_t,
>;
#[doc = " set of functions and callbacks to create an extern custom decoder in the library\nvia the C API interface. This structure is registered with the library by name and\nthen decoders of the type can be created on the decode tree."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ocsd_extern_dcd_fact {
    #[doc = "< Function pointer to create a decoder instance."]
    pub createDecoder: fnCreateCustomDecoder,
    #[doc = "< Function pointer to destroy a decoder instance."]
    pub destroyDecoder: fnDestroyCustomDecoder,
    #[doc = "< Function pointer to extract the CSID from a config structure"]
    pub csidFromConfig: fnGetCSIDFromConfig,
    #[doc = "< Function pointer to print a trace protocol packet in this decoder"]
    pub pktToString: fnPacketToString,
    #[doc = "< protocol ID assigned during registration."]
    pub protocol_id: ocsd_trace_protocol_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ocsd_extern_dcd_fact"][::std::mem::size_of::<_ocsd_extern_dcd_fact>() - 40usize];
    ["Alignment of _ocsd_extern_dcd_fact"]
        [::std::mem::align_of::<_ocsd_extern_dcd_fact>() - 8usize];
    ["Offset of field: _ocsd_extern_dcd_fact::createDecoder"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_fact, createDecoder) - 0usize];
    ["Offset of field: _ocsd_extern_dcd_fact::destroyDecoder"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_fact, destroyDecoder) - 8usize];
    ["Offset of field: _ocsd_extern_dcd_fact::csidFromConfig"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_fact, csidFromConfig) - 16usize];
    ["Offset of field: _ocsd_extern_dcd_fact::pktToString"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_fact, pktToString) - 24usize];
    ["Offset of field: _ocsd_extern_dcd_fact::protocol_id"]
        [::std::mem::offset_of!(_ocsd_extern_dcd_fact, protocol_id) - 32usize];
};
#[doc = " set of functions and callbacks to create an extern custom decoder in the library\nvia the C API interface. This structure is registered with the library by name and\nthen decoders of the type can be created on the decode tree."]
pub type ocsd_extern_dcd_fact_t = _ocsd_extern_dcd_fact;
unsafe extern "C" {
    #[doc = " @name Library Version API\n\n@{*/\n/** Get Library version. Return a 32 bit version in form MMMMnnpp - MMMM = major version, nn = minor version, pp = patch version"]
    pub fn ocsd_get_version() -> u32;
}
unsafe extern "C" {
    #[doc = " Get library version string"]
    pub fn ocsd_get_version_str() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Create a decode tree.\n\n @param src_type : Type of tree - formatted input, or single source input\n @param deformatterCfgFlags : Formatter flags - determine presence of frame syncs etc.\n\n @return dcd_tree_handle_t  : Handle to the decode tree. Handle value set to 0 if creation failed."]
    pub fn ocsd_create_dcd_tree(
        src_type: ocsd_dcd_tree_src_t,
        deformatterCfgFlags: u32,
    ) -> dcd_tree_handle_t;
}
unsafe extern "C" {
    #[doc = " Destroy a decode tree.\n\n Also destroys all the associated processors and decoders for the tree.\n\n @param handle : Handle for decode tree to destroy."]
    pub fn ocsd_destroy_dcd_tree(handle: dcd_tree_handle_t);
}
unsafe extern "C" {
    #[doc = " Input trace data into the decoder.\n\n Large trace source buffers can be broken down into smaller fragments.\n\n @param handle : Handle to decode tree.\n @param op : Datapath operation.\n @param index : Trace buffer byte index for the start of the supplied data block.\n @param dataBlockSize : Size of data block.\n @param *pDataBlock : Pointer to data block.\n @param *numBytesProcessed : Number of bytes actually processed by the decoder.\n\n @return ocsd_datapath_resp_t  : Datapath response code (CONT/WAIT/FATAL)"]
    pub fn ocsd_dt_process_data(
        handle: dcd_tree_handle_t,
        op: ocsd_datapath_op_t,
        index: ocsd_trc_index_t,
        dataBlockSize: u32,
        pDataBlock: *const u8,
        numBytesProcessed: *mut u32,
    ) -> ocsd_datapath_resp_t;
}
unsafe extern "C" {
    #[doc = " Set the trace element output callback function.\n\n This function will be called for each decoded generic trace element generated by\n any full trace decoder in the decode tree.\n\n A single function is used for all trace source IDs in the decode tree.\n\n @param handle : Handle to decode tree.\n @param pFn : Pointer to the callback function.\n @param p_context : opaque context pointer value used in callback function.\n\n @return  ocsd_err_t  : Library error code -  OCSD_OK if successful."]
    pub fn ocsd_dt_set_gen_elem_outfn(
        handle: dcd_tree_handle_t,
        pFn: FnTraceElemIn,
        p_context: *const ::std::os::raw::c_void,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Creates a decoder that is registered with the library under the supplied name.\n Flags determine if a full packet processor / packet decoder pair or\n packet processor only is created.\n Uses the supplied configuration structure.\n\n @param handle : Handle to decode tree.\n @param *decoder_name : Registered name of the decoder to create.\n @param create_flags : Decoder creation options.\n @param *decoder_cfg : Pointer to a valid configuration structure for the named decoder.\n @param *pCSID : Pointer to location to return the configured CoreSight trace ID for the decoder.\n\n @return ocsd_err_t  : Library error code -  OCSD_OK if successful."]
    pub fn ocsd_dt_create_decoder(
        handle: dcd_tree_handle_t,
        decoder_name: *const ::std::os::raw::c_char,
        create_flags: ::std::os::raw::c_int,
        decoder_cfg: *const ::std::os::raw::c_void,
        pCSID: *mut ::std::os::raw::c_uchar,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Remove a decoder from the tree and destroy it.\n\n @param handle :  Handle to decode tree.\n @param CSID : Configured CoreSight trace ID for the decoder.\n\n @return ocsd_err_t  : Library error code -  OCSD_OK if successful."]
    pub fn ocsd_dt_remove_decoder(
        handle: dcd_tree_handle_t,
        CSID: ::std::os::raw::c_uchar,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Attach a callback function to the packet processor.\n\n The callback_type defines the attachment point, either the main packet output\n (only if no decoder attached), or the packet monitor.\n\n @param handle : Handle to decode tree.\n @param CSID : Configured CoreSight trace ID for the decoder.\n @param callback_type : Attachment point\n @param p_fn_pkt_data_in : Pointer to the callback function.\n @param p_context : Opaque context pointer value used in callback function.\n\n @return ocsd_err_t  : Library error code -  OCSD_OK if successful."]
    pub fn ocsd_dt_attach_packet_callback(
        handle: dcd_tree_handle_t,
        CSID: ::std::os::raw::c_uchar,
        callback_type: ocsd_c_api_cb_types,
        p_fn_callback_data: *mut ::std::os::raw::c_void,
        p_context: *const ::std::os::raw::c_void,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Get the stats block for the channel indicated.\n Caller must check p_stats_block->version to esure that the block\n is filled in a compatible manner.\n\n @param handle : Handle to decode tree.\n @param CSID : Configured CoreSight trace ID for the decoder.\n @param p_stats_block: block pointer to set to reference the stats block.\n\n @return ocsd_err_t  : Library error code -  OCSD_OK if valid block pointer returned,\n                      OCSD_ERR_NOTINIT if decoder does not support stats counting."]
    pub fn ocsd_dt_get_decode_stats(
        handle: dcd_tree_handle_t,
        CSID: ::std::os::raw::c_uchar,
        p_stats_block: *mut *mut ocsd_decode_stats_t,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Reset the stats block for the chosens decode channel.\n stats block is reset independently of the decoder reset to allow counts across\n multiple decode runs.\n\n @param handle : Handle to decode tree.\n @param CSID : Configured CoreSight trace ID for the decoder.\n\n @return ocsd_err_t  : Library error code -  OCSD_OK if successful."]
    pub fn ocsd_dt_reset_decode_stats(
        handle: dcd_tree_handle_t,
        CSID: ::std::os::raw::c_uchar,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Add a binary file based memory range accessor to the decode tree.\n\n Adds the entire binary file as a memory space to be accessed\n\n @param handle : Handle to decode tree.\n @param address : Start address of memory area.\n @param mem_space : Associated memory space.\n @param *filepath : Path to binary data file.\n\n @return ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_dt_add_binfile_mem_acc(
        handle: dcd_tree_handle_t,
        address: ocsd_vaddr_t,
        mem_space: ocsd_mem_space_acc_t,
        filepath: *const ::std::os::raw::c_char,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Add a binary file based memory range accessor to the decode tree.\n\n Add a binary file that contains multiple regions of memory with differing\n offsets wihtin the file.\n\n A linked list of file_mem_region_t structures is supplied. Each structure contains an\n offset into the binary file, the start address for this offset and the size of the region.\n\n @param handle : Handle to decode tree.\n @param region_list : Array of memory regions in the file.\n @param num_regions : Size of region array\n @param mem_space : Associated memory space.\n @param *filepath : Path to binary data file.\n\n @return ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_dt_add_binfile_region_mem_acc(
        handle: dcd_tree_handle_t,
        region_array: *const ocsd_file_mem_region_t,
        num_regions: ::std::os::raw::c_int,
        mem_space: ocsd_mem_space_acc_t,
        filepath: *const ::std::os::raw::c_char,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Add a memory buffer based memory range accessor to the decode tree.\n\n @param handle : Handle to decode tree.\n @param address : Start address of memory area.\n @param mem_space : Associated memory space.\n @param *p_mem_buffer : pointer to memory buffer.\n @param mem_length : Size of memory buffer.\n\n @return ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_dt_add_buffer_mem_acc(
        handle: dcd_tree_handle_t,
        address: ocsd_vaddr_t,
        mem_space: ocsd_mem_space_acc_t,
        p_mem_buffer: *const u8,
        mem_length: u32,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Add a memory access callback function. The decoder will call the function for opcode addresses in the\n address range supplied for the memory spaces covered.\n\n @param handle : Handle to decode tree.\n @param st_address :  Start address of memory area covered by the callback.\n @param en_address :  End address of the memory area covered by the callback. (inclusive)\n @param mem_space : Memory space(s) covered by the callback.\n @param p_cb_func : Callback function\n @param p_context : opaque context pointer value used in callback function.\n\n @return OCSD_C_API ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_dt_add_callback_mem_acc(
        handle: dcd_tree_handle_t,
        st_address: ocsd_vaddr_t,
        en_address: ocsd_vaddr_t,
        mem_space: ocsd_mem_space_acc_t,
        p_cb_func: Fn_MemAcc_CB,
        p_context: *const ::std::os::raw::c_void,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Add a memory access callback function. The decoder will call the function for opcode addresses in the\n address range supplied for the memory spaces covered.\n\n @param handle : Handle to decode tree.\n @param st_address :  Start address of memory area covered by the callback.\n @param en_address :  End address of the memory area covered by the callback. (inclusive)\n @param mem_space : Memory space(s) covered by the callback.\n @param p_cb_func : Callback function - Signature for CB with Trace ID passed to client.\n @param p_context : opaque context pointer value used in callback function.\n\n @return OCSD_C_API ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_dt_add_callback_trcid_mem_acc(
        handle: dcd_tree_handle_t,
        st_address: ocsd_vaddr_t,
        en_address: ocsd_vaddr_t,
        mem_space: ocsd_mem_space_acc_t,
        p_cb_func: Fn_MemAccID_CB,
        p_context: *const ::std::os::raw::c_void,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Remove a memory accessor by address and memory space.\n\n @param handle : Handle to decode tree.\n @param st_address : Start address of memory accessor.\n @param mem_space : Memory space(s) covered by the accessor.\n\n @return OCSD_C_API ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_dt_remove_mem_acc(
        handle: dcd_tree_handle_t,
        st_address: ocsd_vaddr_t,
        mem_space: ocsd_mem_space_acc_t,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    pub fn ocsd_tl_log_mapped_mem_ranges(handle: dcd_tree_handle_t);
}
unsafe extern "C" {
    pub fn ocsd_dt_set_mem_acc_cacheing(
        handle: dcd_tree_handle_t,
        enable: ::std::os::raw::c_int,
        page_size: u16,
        nr_pages: ::std::os::raw::c_int,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Initialise the library error logger.\n\n Choose severity of errors logger, and if the errors will be logged to screen and / or logfile.\n\n @param verbosity : Severity of errors that will be logged.\n @param create_output_logger : Set to none-zero to create an output printer.\n\n @return ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_def_errlog_init(
        verbosity: ocsd_err_severity_t,
        create_output_logger: ::std::os::raw::c_int,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Configure the output logger. Choose STDOUT, STDERR and/or log to file.\n Optionally provide a log file name.\n\n @param output_flags : OR combination of required  C_API_MSGLOGOUT_FLG_* flags.\n @param *log_file_name : optional filename if logging to file. Set to NULL if not needed.\n\n @return OCSD_C_API ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_def_errlog_config_output(
        output_flags: ::std::os::raw::c_int,
        log_file_name: *const ::std::os::raw::c_char,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Configure the library default error logger to send all strings it is outputting back to the client\n to allow printing within the client application. This is in additional to any other log destinations\n set in ocsd_def_errlog_init().\n\n @param *p_context : opaque context pointer\n @param p_str_print_cb : client callback function to \"print\" logstring."]
    pub fn ocsd_def_errlog_set_strprint_cb(
        handle: dcd_tree_handle_t,
        p_context: *mut ::std::os::raw::c_void,
        p_str_print_cb: FnDefLoggerPrintStrCB,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Print a message via the library output printer - if enabled.\n\n @param *msg : Message to output.\n"]
    pub fn ocsd_def_errlog_msgout(msg: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Convert an error code into a string.\n\n @param err         : error code.\n @param buffer      : buffer for return string\n @param buffer_size : length of buffer."]
    pub fn ocsd_err_str(
        err: ocsd_err_t,
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " returns the last error logged by the system, with the related trace byte index, trace channel id,\n and any error message related string.\n If index or channel ID are not valid these will return OCSD_BAD_TRC_INDEX and OCSD_BAD_CS_SRC_ID.\n\n return value is the error code of the last logged error, OCSD_OK for no error available.\n\n @param index      : returns trace byte index relating to error, or OCSD_BAD_TRC_INDEX\n @param chan_id    : returns trace channel ID relating to error, or OCSD_BAD_CS_SRC_ID\n @param message    : buffer to copy the last error message.\n @param message_len: length of message buffer."]
    pub fn ocsd_get_last_err(
        index: *mut ocsd_trc_index_t,
        chan_id: *mut u8,
        message: *mut ::std::os::raw::c_char,
        message_len: ::std::os::raw::c_int,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Take a packet structure and render a string representation of the packet data.\n\n Returns a '0' terminated string of (buffer_size - 1) length or less.\n\n @param pkt_protocol : Packet protocol type - used to interpret the packet pointer\n @param *p_pkt : pointer to a valid packet structure of protocol type. cast to void *.\n @param *buffer : character buffer for string.\n @param buffer_size : size of character buffer.\n\n @return  ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_pkt_str(
        pkt_protocol: ocsd_trace_protocol_t,
        p_pkt: *const ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: ::std::os::raw::c_int,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Get a string representation of the generic trace element.\n\n @param *p_pkt : pointer to valid generic element structure.\n @param *buffer : character buffer for string.\n @param buffer_size : size of character buffer.\n\n @return ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_gen_elem_str(
        p_pkt: *const ocsd_generic_trace_elem,
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: ::std::os::raw::c_int,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Init a generic element with type, clearing any flags etc."]
    pub fn ocsd_gen_elem_init(p_pkt: *mut ocsd_generic_trace_elem, elem_type: ocsd_gen_trc_elem_t);
}
unsafe extern "C" {
    #[doc = " Set a raw frame printer on the trace frame demuxer. Allows inspection of raw trace data frames for debug.\n Prints via the library default error logging mechanisms.\n\n The flags input determines the data printed. OR combination of one or both of:\n OCSD_DFRMTR_PACKED_RAW_OUT   : Output the undemuxed raw data frames.\n OCSD_DFRMTR_UNPACKED_RAW_OUT : Output the raw data by trace ID after unpacking the frame.\n\n @param handle : Handle to decode tree.\n @param flags : indicates type of raw frames to print.\n\n @return ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_dt_set_raw_frame_printer(
        handle: dcd_tree_handle_t,
        flags: ::std::os::raw::c_int,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Set a library printer on the generic element output of a full decoder.\n\n @param handle : Handle to decode tree.\n\n @return ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_dt_set_gen_elem_printer(handle: dcd_tree_handle_t) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Attach a library printer to the packet processor. May be attached to the main packet output, or the monitor\n output if the main packet output is to be attached to a packet decoder in the datapath.\n\n @param handle : Handle to decode tree.\n @param cs_id  : Coresight trace ID for stream to print.\n @param monitor: 0 to attach printer directly to datapath packet output, 1 to attach to packet monitor output\n\n @return ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_dt_set_pkt_protocol_printer(
        handle: dcd_tree_handle_t,
        cs_id: u8,
        monitor: ::std::os::raw::c_int,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Register a custom decoder with the library\n\n@param *name : Name under which to register the decoder.\n@param *p_dcd_fact : Custom decoder factory structure.\n\n@return ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_register_custom_decoder(
        name: *const ::std::os::raw::c_char,
        p_dcd_fact: *mut ocsd_extern_dcd_fact_t,
    ) -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Clear all registered decoders - library cleanup\n\n@return ocsd_err_t  : Library error code -  RCDTL_OK if successful."]
    pub fn ocsd_deregister_decoders() -> ocsd_err_t;
}
unsafe extern "C" {
    #[doc = " Get a string representation of a custom protocol packet.\n\nSpecific function to extract the packet string for a custom protocol ID only. Custom IDs are allocated to decoder factories\nduring the ocsd_register_custom_decoder() process.\n\nThis function is called by ocsd_pkt_str() when the incoming protocol is a custom ID.\n\n@param pkt_protocol : Packet protocol type - must be in the custom ID range ( >= OCSD_PROTOCOL_CUSTOM_0, < OCSD_PROTOCOL_END)\n@param *p_pkt : pointer to a valid packet structure of protocol type. cast to void *.\n@param *buffer : character buffer for string.\n@param buffer_size : size of character buffer.\n\n@return ocsd_err_t  : Library error code -  RCDTL_OK if successful, OCSD_ERR_NO_PROTOCOL if input ID not in custom range or not in use."]
    pub fn ocsd_cust_protocol_to_str(
        pkt_protocol: ocsd_trace_protocol_t,
        trc_pkt: *const ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ocsd_err_t;
}
